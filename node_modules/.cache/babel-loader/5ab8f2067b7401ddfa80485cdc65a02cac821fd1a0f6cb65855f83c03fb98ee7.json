{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useMemo } from \"react\";\nimport { Uniform, Texture, Color, CanvasTexture, RepeatWrapping, NearestFilter } from \"three\";\nimport { Effect } from \"postprocessing\";\nconst fragment = `\nuniform sampler2D uCharacters;\nuniform float uCharactersCount;\nuniform float uCellSize;\nuniform bool uInvert;\nuniform vec3 uColor;\n\nconst vec2 SIZE = vec2(16.);\n\nvec3 greyscale(vec3 color, float strength) {\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\n    return mix(color, vec3(g), strength);\n}\n\nvec3 greyscale(vec3 color) {\n    return greyscale(color, 1.0);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec2 cell = resolution / uCellSize;\n    vec2 grid = 1.0 / cell;\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\n    float greyscaled = greyscale(pixelized.rgb).r;\n\n    if (uInvert) {\n        greyscaled = 1.0 - greyscaled;\n    }\n\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\n\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\n    asciiCharacter.a = pixelized.a;\n    outputColor = asciiCharacter;\n}\n`;\nclass ASCIIEffect extends Effect {\n  constructor({\n    font = \"arial\",\n    characters = ` .:,'-^=*+?!|0#X%WM@`,\n    fontSize = 54,\n    cellSize = 16,\n    color = \"#ffffff\",\n    invert = false\n  } = {}) {\n    const uniforms = /* @__PURE__ */new Map([[\"uCharacters\", new Uniform(new Texture())], [\"uCellSize\", new Uniform(cellSize)], [\"uCharactersCount\", new Uniform(characters.length)], [\"uColor\", new Uniform(new Color(color))], [\"uInvert\", new Uniform(invert)]]);\n    super(\"ASCIIEffect\", fragment, {\n      uniforms\n    });\n    const charactersTextureUniform = this.uniforms.get(\"uCharacters\");\n    if (charactersTextureUniform) {\n      charactersTextureUniform.value = this.createCharactersTexture(characters, font, fontSize);\n    }\n  }\n  /** Draws the characters on a Canvas and returns a texture */\n  createCharactersTexture(characters, font, fontSize) {\n    const canvas = document.createElement(\"canvas\");\n    const SIZE = 1024;\n    const MAX_PER_ROW = 16;\n    const CELL = SIZE / MAX_PER_ROW;\n    canvas.width = canvas.height = SIZE;\n    const texture = new CanvasTexture(canvas, void 0, RepeatWrapping, RepeatWrapping, NearestFilter, NearestFilter);\n    const context = canvas.getContext(\"2d\");\n    if (!context) {\n      throw new Error(\"Context not available\");\n    }\n    context.clearRect(0, 0, SIZE, SIZE);\n    context.font = `${fontSize}px ${font}`;\n    context.textAlign = \"center\";\n    context.textBaseline = \"middle\";\n    context.fillStyle = \"#fff\";\n    for (let i = 0; i < characters.length; i++) {\n      const char = characters[i];\n      const x = i % MAX_PER_ROW;\n      const y = Math.floor(i / MAX_PER_ROW);\n      context.fillText(char, x * CELL + CELL / 2, y * CELL + CELL / 2);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nconst ASCII = forwardRef(({\n  font = \"arial\",\n  characters = ` .:,'-^=*+?!|0#X%WM@`,\n  fontSize = 54,\n  cellSize = 16,\n  color = \"#ffffff\",\n  invert = false\n}, fref) => {\n  const effect = useMemo(() => new ASCIIEffect({\n    characters,\n    font,\n    fontSize,\n    cellSize,\n    color,\n    invert\n  }), [characters, fontSize, cellSize, color, invert, font]);\n  return /* @__PURE__ */jsx(\"primitive\", {\n    ref: fref,\n    object: effect\n  });\n});\nexport { ASCII };","map":{"version":3,"names":["fragment","ASCIIEffect","Effect","constructor","font","characters","fontSize","cellSize","color","invert","uniforms","Map","Uniform","Texture","length","Color","charactersTextureUniform","get","value","createCharactersTexture","canvas","document","createElement","SIZE","MAX_PER_ROW","CELL","width","height","texture","CanvasTexture","RepeatWrapping","NearestFilter","context","getContext","Error","clearRect","textAlign","textBaseline","fillStyle","i","char","x","y","Math","floor","fillText","needsUpdate","ASCII","forwardRef","fref","effect","useMemo","jsx","ref","object"],"sources":["/Users/kasaikazunobu/project/babel/babel-project/node_modules/@react-three/postprocessing/src/effects/ASCII.tsx"],"sourcesContent":["// From: https://github.com/emilwidlund/ASCII\n// https://twitter.com/emilwidlund/status/1652386482420609024\n\nimport { forwardRef, useMemo } from 'react'\nimport { CanvasTexture, Color, NearestFilter, RepeatWrapping, Texture, Uniform } from 'three'\nimport { Effect } from 'postprocessing'\n\nconst fragment = `\nuniform sampler2D uCharacters;\nuniform float uCharactersCount;\nuniform float uCellSize;\nuniform bool uInvert;\nuniform vec3 uColor;\n\nconst vec2 SIZE = vec2(16.);\n\nvec3 greyscale(vec3 color, float strength) {\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\n    return mix(color, vec3(g), strength);\n}\n\nvec3 greyscale(vec3 color) {\n    return greyscale(color, 1.0);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec2 cell = resolution / uCellSize;\n    vec2 grid = 1.0 / cell;\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\n    float greyscaled = greyscale(pixelized.rgb).r;\n\n    if (uInvert) {\n        greyscaled = 1.0 - greyscaled;\n    }\n\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\n\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\n    asciiCharacter.a = pixelized.a;\n    outputColor = asciiCharacter;\n}\n`\n\ninterface IASCIIEffectProps {\n  font?: string\n  characters?: string\n  fontSize?: number\n  cellSize?: number\n  color?: string\n  invert?: boolean\n}\n\nclass ASCIIEffect extends Effect {\n  constructor({\n    font = 'arial',\n    characters = ` .:,'-^=*+?!|0#X%WM@`,\n    fontSize = 54,\n    cellSize = 16,\n    color = '#ffffff',\n    invert = false,\n  }: IASCIIEffectProps = {}) {\n    const uniforms = new Map<string, Uniform>([\n      ['uCharacters', new Uniform(new Texture())],\n      ['uCellSize', new Uniform(cellSize)],\n      ['uCharactersCount', new Uniform(characters.length)],\n      ['uColor', new Uniform(new Color(color))],\n      ['uInvert', new Uniform(invert)],\n    ])\n\n    super('ASCIIEffect', fragment, { uniforms })\n\n    const charactersTextureUniform = this.uniforms.get('uCharacters')\n\n    if (charactersTextureUniform) {\n      charactersTextureUniform.value = this.createCharactersTexture(characters, font, fontSize)\n    }\n  }\n\n  /** Draws the characters on a Canvas and returns a texture */\n  public createCharactersTexture(characters: string, font: string, fontSize: number): THREE.Texture {\n    const canvas = document.createElement('canvas')\n    const SIZE = 1024\n    const MAX_PER_ROW = 16\n    const CELL = SIZE / MAX_PER_ROW\n\n    canvas.width = canvas.height = SIZE\n    const texture = new CanvasTexture(canvas, undefined, RepeatWrapping, RepeatWrapping, NearestFilter, NearestFilter)\n    const context = canvas.getContext('2d')\n\n    if (!context) {\n      throw new Error('Context not available')\n    }\n\n    context.clearRect(0, 0, SIZE, SIZE)\n    context.font = `${fontSize}px ${font}`\n    context.textAlign = 'center'\n    context.textBaseline = 'middle'\n    context.fillStyle = '#fff'\n\n    for (let i = 0; i < characters.length; i++) {\n      const char = characters[i]\n      const x = i % MAX_PER_ROW\n      const y = Math.floor(i / MAX_PER_ROW)\n      context.fillText(char, x * CELL + CELL / 2, y * CELL + CELL / 2)\n    }\n\n    texture.needsUpdate = true\n    return texture\n  }\n}\n\nexport const ASCII = forwardRef<ASCIIEffect, IASCIIEffectProps>(\n  (\n    {\n      font = 'arial',\n      characters = ` .:,'-^=*+?!|0#X%WM@`,\n      fontSize = 54,\n      cellSize = 16,\n      color = '#ffffff',\n      invert = false,\n    },\n    fref\n  ) => {\n    const effect = useMemo(\n      () => new ASCIIEffect({ characters, font, fontSize, cellSize, color, invert }),\n      [characters, fontSize, cellSize, color, invert, font]\n    )\n    return <primitive ref={fref} object={effect} />\n  }\n)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}