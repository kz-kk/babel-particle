{"ast":null,"code":"import * as THREE from \"three\";\nconst PoissionBlur = {\n  uniforms: {\n    sceneDiffuse: {\n      value: null\n    },\n    sceneDepth: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    projMat: {\n      value: new THREE.Matrix4()\n    },\n    viewMat: {\n      value: new THREE.Matrix4()\n    },\n    projectionMatrixInv: {\n      value: new THREE.Matrix4()\n    },\n    viewMatrixInv: {\n      value: new THREE.Matrix4()\n    },\n    cameraPos: {\n      value: new THREE.Vector3()\n    },\n    resolution: {\n      value: new THREE.Vector2()\n    },\n    time: {\n      value: 0\n    },\n    r: {\n      value: 5\n    },\n    blueNoise: {\n      value: null\n    },\n    radius: {\n      value: 12\n    },\n    worldRadius: {\n      value: 5\n    },\n    index: {\n      value: 0\n    },\n    poissonDisk: {\n      value: []\n    },\n    distanceFalloff: {\n      value: 1\n    },\n    near: {\n      value: 0.1\n    },\n    far: {\n      value: 1e3\n    },\n    logDepth: {\n      value: false\n    },\n    screenSpaceRadius: {\n      value: false\n    }\n  },\n  depthWrite: false,\n  depthTest: false,\n  vertexShader: (/* glsl */\n  `\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = vec4(position, 1.0);\n\t\t}`),\n  fragmentShader: (/* glsl */\n  `\n\t\tuniform sampler2D sceneDiffuse;\n    uniform highp sampler2D sceneDepth;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D blueNoise;\n    uniform mat4 projectionMatrixInv;\n    uniform mat4 viewMatrixInv;\n    uniform vec2 resolution;\n    uniform float r;\n    uniform float radius;\n     uniform float worldRadius;\n    uniform float index;\n     uniform float near;\n     uniform float far;\n     uniform float distanceFalloff;\n     uniform bool logDepth;\n     uniform bool screenSpaceRadius;\n    varying vec2 vUv;\n\n    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)\n    {\n        highp float z_n = 2.0 * d - 1.0;\n        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));\n    }\n    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {\n     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;\n     float a = farZ / (farZ - nearZ);\n     float b = farZ * nearZ / (nearZ - farZ);\n     float linDepth = a + b / depth;\n     return linearize_depth(linDepth, nearZ, farZ);\n   }\n   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {\n     return nearZ + (farZ - nearZ) * d;\n   }\n   vec3 getWorldPosLog(vec3 posS) {\n     vec2 uv = posS.xy;\n     float z = posS.z;\n     float nearZ =near;\n     float farZ = far;\n     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;\n     float a = farZ / (farZ - nearZ);\n     float b = farZ * nearZ / (nearZ - farZ);\n     float linDepth = a + b / depth;\n     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;\n     vec4 wpos = projectionMatrixInv * clipVec;\n     return wpos.xyz / wpos.w;\n   }\n    vec3 getWorldPos(float depth, vec2 coord) {\n     #ifdef LOGDEPTH\n          return getWorldPosLog(vec3(coord, depth));\n     #endif\n        \n        float z = depth * 2.0 - 1.0;\n        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;\n        // Perspective division\n       vec4 worldSpacePosition = viewSpacePosition;\n       worldSpacePosition.xyz /= worldSpacePosition.w;\n        return worldSpacePosition.xyz;\n    }\n    #include <common>\n    #define NUM_SAMPLES 16\n    uniform vec2 poissonDisk[NUM_SAMPLES];\n    void main() {\n        const float pi = 3.14159;\n        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n        vec2 uv = vUv;\n        vec4 data = texture2D(tDiffuse, vUv);\n        float occlusion = data.a;\n        float baseOcc = data.a;\n        vec3 normal = data.rgb * 2.0 - 1.0;\n        float count = 1.0;\n        float d = texture2D(sceneDepth, vUv).x;\n        if (d == 1.0) {\n          gl_FragColor = data;\n          return;\n        }\n        vec3 worldPos = getWorldPos(d, vUv);\n        float size = radius;\n        float angle;\n        if (index == 0.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;\n        } else if (index == 1.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;\n        } else if (index == 2.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;\n        } else {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;\n        }\n\n        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n        float radiusToUse = screenSpaceRadius ? distance(\n          worldPos,\n          getWorldPos(d, vUv +\n            vec2(worldRadius, 0.0) / resolution)\n        ) : worldRadius;\n        float distanceFalloffToUse =screenSpaceRadius ?\n            radiusToUse * distanceFalloff\n        : distanceFalloff;\n\n\n        for(int i = 0; i < NUM_SAMPLES; i++) {\n            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;\n            vec4 dataSample = texture2D(tDiffuse, uv + offset);\n            float occSample = dataSample.a;\n            vec3 normalSample = dataSample.rgb * 2.0 - 1.0;\n            float dSample = texture2D(sceneDepth, uv + offset).x;\n            vec3 worldPosSample = getWorldPos(dSample, uv + offset);\n            float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));\n            float rangeCheck = dSample == 1.0 ? 0.0 :exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0) * (1.0 - abs(occSample - baseOcc));\n            occlusion += occSample * rangeCheck;\n            count += rangeCheck;\n        }\n        if (count > 0.0) {\n          occlusion /= count;\n        }\n        #ifdef LOGDEPTH\n          occlusion = clamp(occlusion, 0.0, 1.0);\n          if (occlusion == 0.0) {\n            occlusion = 1.0;\n          }\n        #endif\n        gl_FragColor = vec4(0.5 + 0.5 * normal, occlusion);\n    }\n    `)\n};\nexport { PoissionBlur };","map":{"version":3,"names":["PoissionBlur","uniforms","sceneDiffuse","value","sceneDepth","tDiffuse","projMat","THREE","Matrix4","viewMat","projectionMatrixInv","viewMatrixInv","cameraPos","Vector3","resolution","Vector2","time","r","blueNoise","radius","worldRadius","index","poissonDisk","distanceFalloff","near","far","logDepth","screenSpaceRadius","depthWrite","depthTest","vertexShader","fragmentShader"],"sources":["/Users/kasaikazunobu/project/babel/babel-project/node_modules/@react-three/postprocessing/src/effects/N8AO/PoissionBlur.js"],"sourcesContent":["import * as THREE from 'three'\n\nconst PoissionBlur = {\n  uniforms: {\n    sceneDiffuse: { value: null },\n    sceneDepth: { value: null },\n    tDiffuse: { value: null },\n    projMat: { value: new THREE.Matrix4() },\n    viewMat: { value: new THREE.Matrix4() },\n    projectionMatrixInv: { value: new THREE.Matrix4() },\n    viewMatrixInv: { value: new THREE.Matrix4() },\n    cameraPos: { value: new THREE.Vector3() },\n    resolution: { value: new THREE.Vector2() },\n    time: { value: 0.0 },\n    r: { value: 5.0 },\n    blueNoise: { value: null },\n    radius: { value: 12.0 },\n    worldRadius: { value: 5.0 },\n    index: { value: 0.0 },\n    poissonDisk: { value: [] },\n    distanceFalloff: { value: 1.0 },\n    near: { value: 0.1 },\n    far: { value: 1000.0 },\n    logDepth: { value: false },\n    screenSpaceRadius: { value: false },\n  },\n  depthWrite: false,\n  depthTest: false,\n\n  vertexShader: /* glsl */ `\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = vec4(position, 1.0);\n\t\t}`,\n  fragmentShader: /* glsl */ `\n\t\tuniform sampler2D sceneDiffuse;\n    uniform highp sampler2D sceneDepth;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D blueNoise;\n    uniform mat4 projectionMatrixInv;\n    uniform mat4 viewMatrixInv;\n    uniform vec2 resolution;\n    uniform float r;\n    uniform float radius;\n     uniform float worldRadius;\n    uniform float index;\n     uniform float near;\n     uniform float far;\n     uniform float distanceFalloff;\n     uniform bool logDepth;\n     uniform bool screenSpaceRadius;\n    varying vec2 vUv;\n\n    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)\n    {\n        highp float z_n = 2.0 * d - 1.0;\n        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));\n    }\n    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {\n     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;\n     float a = farZ / (farZ - nearZ);\n     float b = farZ * nearZ / (nearZ - farZ);\n     float linDepth = a + b / depth;\n     return linearize_depth(linDepth, nearZ, farZ);\n   }\n   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {\n     return nearZ + (farZ - nearZ) * d;\n   }\n   vec3 getWorldPosLog(vec3 posS) {\n     vec2 uv = posS.xy;\n     float z = posS.z;\n     float nearZ =near;\n     float farZ = far;\n     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;\n     float a = farZ / (farZ - nearZ);\n     float b = farZ * nearZ / (nearZ - farZ);\n     float linDepth = a + b / depth;\n     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;\n     vec4 wpos = projectionMatrixInv * clipVec;\n     return wpos.xyz / wpos.w;\n   }\n    vec3 getWorldPos(float depth, vec2 coord) {\n     #ifdef LOGDEPTH\n          return getWorldPosLog(vec3(coord, depth));\n     #endif\n        \n        float z = depth * 2.0 - 1.0;\n        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;\n        // Perspective division\n       vec4 worldSpacePosition = viewSpacePosition;\n       worldSpacePosition.xyz /= worldSpacePosition.w;\n        return worldSpacePosition.xyz;\n    }\n    #include <common>\n    #define NUM_SAMPLES 16\n    uniform vec2 poissonDisk[NUM_SAMPLES];\n    void main() {\n        const float pi = 3.14159;\n        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n        vec2 uv = vUv;\n        vec4 data = texture2D(tDiffuse, vUv);\n        float occlusion = data.a;\n        float baseOcc = data.a;\n        vec3 normal = data.rgb * 2.0 - 1.0;\n        float count = 1.0;\n        float d = texture2D(sceneDepth, vUv).x;\n        if (d == 1.0) {\n          gl_FragColor = data;\n          return;\n        }\n        vec3 worldPos = getWorldPos(d, vUv);\n        float size = radius;\n        float angle;\n        if (index == 0.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;\n        } else if (index == 1.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;\n        } else if (index == 2.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;\n        } else {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;\n        }\n\n        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n        float radiusToUse = screenSpaceRadius ? distance(\n          worldPos,\n          getWorldPos(d, vUv +\n            vec2(worldRadius, 0.0) / resolution)\n        ) : worldRadius;\n        float distanceFalloffToUse =screenSpaceRadius ?\n            radiusToUse * distanceFalloff\n        : distanceFalloff;\n\n\n        for(int i = 0; i < NUM_SAMPLES; i++) {\n            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;\n            vec4 dataSample = texture2D(tDiffuse, uv + offset);\n            float occSample = dataSample.a;\n            vec3 normalSample = dataSample.rgb * 2.0 - 1.0;\n            float dSample = texture2D(sceneDepth, uv + offset).x;\n            vec3 worldPosSample = getWorldPos(dSample, uv + offset);\n            float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));\n            float rangeCheck = dSample == 1.0 ? 0.0 :exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0) * (1.0 - abs(occSample - baseOcc));\n            occlusion += occSample * rangeCheck;\n            count += rangeCheck;\n        }\n        if (count > 0.0) {\n          occlusion /= count;\n        }\n        #ifdef LOGDEPTH\n          occlusion = clamp(occlusion, 0.0, 1.0);\n          if (occlusion == 0.0) {\n            occlusion = 1.0;\n          }\n        #endif\n        gl_FragColor = vec4(0.5 + 0.5 * normal, occlusion);\n    }\n    `,\n}\n\nexport { PoissionBlur }\n"],"mappings":";AAEK,MAACA,YAAA,GAAe;EACnBC,QAAA,EAAU;IACRC,YAAA,EAAc;MAAEC,KAAA,EAAO;IAAM;IAC7BC,UAAA,EAAY;MAAED,KAAA,EAAO;IAAM;IAC3BE,QAAA,EAAU;MAAEF,KAAA,EAAO;IAAM;IACzBG,OAAA,EAAS;MAAEH,KAAA,EAAO,IAAII,KAAA,CAAMC,OAAA,CAAO;IAAI;IACvCC,OAAA,EAAS;MAAEN,KAAA,EAAO,IAAII,KAAA,CAAMC,OAAA,CAAO;IAAI;IACvCE,mBAAA,EAAqB;MAAEP,KAAA,EAAO,IAAII,KAAA,CAAMC,OAAA,CAAO;IAAI;IACnDG,aAAA,EAAe;MAAER,KAAA,EAAO,IAAII,KAAA,CAAMC,OAAA,CAAO;IAAI;IAC7CI,SAAA,EAAW;MAAET,KAAA,EAAO,IAAII,KAAA,CAAMM,OAAA,CAAO;IAAI;IACzCC,UAAA,EAAY;MAAEX,KAAA,EAAO,IAAII,KAAA,CAAMQ,OAAA,CAAO;IAAI;IAC1CC,IAAA,EAAM;MAAEb,KAAA,EAAO;IAAK;IACpBc,CAAA,EAAG;MAAEd,KAAA,EAAO;IAAK;IACjBe,SAAA,EAAW;MAAEf,KAAA,EAAO;IAAM;IAC1BgB,MAAA,EAAQ;MAAEhB,KAAA,EAAO;IAAM;IACvBiB,WAAA,EAAa;MAAEjB,KAAA,EAAO;IAAK;IAC3BkB,KAAA,EAAO;MAAElB,KAAA,EAAO;IAAK;IACrBmB,WAAA,EAAa;MAAEnB,KAAA,EAAO;IAAI;IAC1BoB,eAAA,EAAiB;MAAEpB,KAAA,EAAO;IAAK;IAC/BqB,IAAA,EAAM;MAAErB,KAAA,EAAO;IAAK;IACpBsB,GAAA,EAAK;MAAEtB,KAAA,EAAO;IAAQ;IACtBuB,QAAA,EAAU;MAAEvB,KAAA,EAAO;IAAO;IAC1BwB,iBAAA,EAAmB;MAAExB,KAAA,EAAO;IAAO;EACpC;EACDyB,UAAA,EAAY;EACZC,SAAA,EAAW;EAEXC,YAAA;EAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;EAMzBC,cAAA;EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6H7B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}