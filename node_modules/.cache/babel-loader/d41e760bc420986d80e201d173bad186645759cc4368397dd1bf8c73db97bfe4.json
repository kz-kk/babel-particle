{"ast":null,"code":"import { Effect, Selection, Pass, RenderPass, DepthPass } from \"postprocessing\";\nimport { ShaderChunk, Color, Vector2, WebGLCubeRenderTarget, Uniform, CubeCamera, PMREMGenerator, LinearFilter, Vector3, Texture, WebGLRenderTarget, HalfFloatType, WebGLMultipleRenderTargets, Quaternion, NearestFilter, FramebufferTexture, RGBAFormat, ShaderMaterial, Matrix3, REVISION, TangentSpaceNormalMap, GLSL3, Matrix4, VideoTexture, DataTexture, FloatType } from \"three\";\nconst boxBlur = /* glsl */\n`\n  uniform float blur;\n  uniform float blurSharpness;\n  uniform int blurKernel;\n\n  vec3 denoise(\n    vec3 center,\n    sampler2D tex,\n    vec2 uv,\n    vec2 invTexSize,\n    float blur,\n    float blurSharpness,\n    int blurKernel\n  ) {\n    vec3 color, col;\n    float total, weight;\n\n    for (int x = -blurKernel; x <= blurKernel; x++) {\n      for (int y=-blurKernel; y<=blurKernel; y++) {\n        col = textureLod(tex, uv + vec2(x,y) * invTexSize, 0.0).rgb;\n        weight = 1.0-abs(dot(col - center, vec3(0.25)));\n        weight = pow(weight, blurSharpness);\n        color += col * weight;\n        total += weight;\n      }\n    }\n\n    return color / total;\n  }\n`;\nconst finalSSRShader = /* glsl */\n`\n  #define MODE_DEFAULT 0\n  #define MODE_REFLECTIONS 1\n  #define MODE_RAW_REFLECTION 2\n  #define MODE_BLURRED_REFLECTIONS 3\n  #define MODE_INPUT 4\n  #define MODE_BLUR_MIX 5\n  #define FLOAT_EPSILON 0.00001\n  // uniform sampler2D inputTexture;\n  uniform sampler2D reflectionsTexture;\n  // uniform float samples;\n\n  ${boxBlur}\n\n  void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec4 reflectionsTexel=texture2D(reflectionsTexture, vUv);\n    ivec2 size = textureSize(reflectionsTexture, 0);\n    vec2 invTexSize= 1.0 / vec2(size.x, size.y);\n    vec3 reflectionClr = reflectionsTexel.xyz;\n    if (blur > FLOAT_EPSILON) {\n      vec3 blurredReflectionsColor = denoise(\n        reflectionsTexel.rgb,\n        reflectionsTexture,\n        vUv,\n        invTexSize,\n        blur,\n        blurSharpness,\n        blurKernel\n      );\n      reflectionClr = mix(reflectionClr, blurredReflectionsColor.rgb, blur);\n    }\n\n    #if RENDER_MODE == MODE_DEFAULT\n      outputColor = vec4(inputColor.rgb+reflectionClr, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_REFLECTIONS\n      outputColor = vec4(reflectionClr, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_RAW_REFLECTION\n      outputColor = vec4(reflectionsTexel.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_BLURRED_REFLECTIONS\n      outputColor = vec4(blurredReflectionsTexel.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_INPUT\n      outputColor = vec4(inputColor.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_BLUR_MIX\n      outputColor = vec4(vec3(blur), 1.0);\n    #endif\n  }\n`;\nconst helperFunctions = /* glsl */\n`\n  vec3 getViewPosition(const float depth) {\n    float clipW= _projectionMatrix[2][3] * depth + _projectionMatrix[3][3];\n    vec4 clipPosition = vec4((vec3(vUv, depth) - 0.5) * 2.0, 1.0);\n    clipPosition *= clipW;\n    return(_inverseProjectionMatrix * clipPosition).xyz;\n  }\n\n  float getViewZ(const in float depth) {\n    #ifdef PERSPECTIVE_CAMERA\n      return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    #else\n      return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n    #endif\n  }\n\n  vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){\n    vec4 ndc = vec4((uv.x - 0.5) * 2.0,(uv.y - 0.5)* 2.0, (depth - 0.5) * 2.0, 1.0);\n    vec4 clip= _inverseProjectionMatrix*ndc;\n    vec4 view = cameraMatrixWorld * (clip / clip.w);\n    return view.xyz;\n  }\n\n  #define Scale (vec3(0.8, 0.8, 0.8))\n  #define K (19.19)\n\n  vec3 hash(vec3 a) {\n    a = fract(a * Scale);\n    a += dot(a, a.yxz + K);\n    return fract((a.xxy + a.yxx) * a.zyx);\n  }\n\n  float fresnel_dielectric_cos(float cosi, float eta){\n    float c = abs(cosi);\n    float g = eta * eta - 1.0 +  c* c;\n    float result;\n\n    if (g > 0.0){\n      g = sqrt(g);\n      float A = (g - c) / (g + c);\n      float B = (c* (g + c) - 1.0) / (c * (g - c) + 1.0);\n      result = 0.5 * A * A * (1.0 + B * B);\n    } else {\n      result = 1.0;\n    }\n    \n    return result;\n  }\n\n  float fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta){\n    float cosine = dot(Incoming, Normal);\n    return min(1.0, 5.0 * fresnel_dielectric_cos(cosine, eta));\n  }\n`;\nconst trCompose = /* glsl */\n`\n  #define INV_EULER 0.36787944117144233\n\n  alpha = velocityDisocclusion < FLOAT_EPSILON ? (alpha + 0.0075) : 0.0;\n  alpha = clamp(alpha, 0.0, 1.0);\n  bool needsBlur = !didReproject || velocityDisocclusion > 0.5;\n\n  #ifdef boxBlur\n    if (needsBlur) inputColor = boxBlurredColor;\n  #endif\n\n  if (alpha == 1.0) {\n    outputColor = accumulatedColor;\n  } else {\n    float m = mix(alpha, 1.0, blend);\n    if (needsBlur) m = 0.0;\n    outputColor = accumulatedColor * m + inputColor * (1.0 - m);\n  }\n`;\nclass MRTMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: \"MRTMaterial\",\n      defines: {\n        USE_UV: \"\",\n        TEMPORAL_RESOLVE: \"\"\n      },\n      uniforms: {\n        opacity: new Uniform(1),\n        normalMap: new Uniform(null),\n        normalScale: new Uniform(new Vector2(1, 1)),\n        uvTransform: new Uniform(new Matrix3()),\n        roughness: new Uniform(1),\n        roughnessMap: new Uniform(null)\n      },\n      vertexShader: (/* glsl */\n      `\n        #ifdef USE_MRT\n          varying vec2 vHighPrecisionZW;\n        #endif\n        #define NORMAL\n        #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n          varying vec3 vViewPosition;\n        #endif\n        #include <common>\n        #include <uv_pars_vertex>\n        #include <displacementmap_pars_vertex>\n        #include <normal_pars_vertex>\n        #include <morphtarget_pars_vertex>\n        #include <skinning_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n        #ifdef USE_UV\n          ${REVISION.replace(/\\D+/g, \"\") >= 151 ? \"uniform mat3 uvTransform;\" : \"\"}\n        #endif\n        void main() {\n          #include <uv_vertex>\n          #include <beginnormal_vertex>\n          #include <morphnormal_vertex>\n          #include <skinbase_vertex>\n          #include <skinnormal_vertex>\n          #include <defaultnormal_vertex>\n          #include <normal_vertex>\n          #include <begin_vertex>\n          #include <morphtarget_vertex>\n          #include <skinning_vertex>\n          #include <displacementmap_vertex>\n          #include <project_vertex>\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n            vViewPosition = -mvPosition.xyz;\n          #endif\n          #ifdef USE_MRT\n            vHighPrecisionZW = gl_Position.zw;\n          #endif\n          #ifdef USE_UV\n            vUv = (uvTransform * vec3(uv, 1)).xy;\n          #endif\n        }\n      `),\n      fragmentShader: (/* glsl */\n      `\n        #define NORMAL\n        #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n          varying vec3 vViewPosition;\n        #endif\n        #include <packing>\n        #include <uv_pars_fragment>\n        #include <normal_pars_fragment>\n        #include <bumpmap_pars_fragment>\n        #include <normalmap_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n        #include <roughnessmap_pars_fragment>\n\n        #ifdef USE_MRT\n          layout(location = 0) out vec4 gNormal;\n          layout(location = 1) out vec4 gDepth;\n          varying vec2 vHighPrecisionZW;\n        #endif\n        uniform float roughness;\n        void main() {\n          #include <clipping_planes_fragment>\n          #include <logdepthbuf_fragment>\n          #include <normal_fragment_begin>\n          #include <normal_fragment_maps>\n\n          float roughnessFactor = roughness;\n\n          if (roughness > 10.0e9){\n            roughnessFactor = 1.;\n          } else {\n            #ifdef useRoughnessMap\n              vec4 texelRoughness = texture2D(roughnessMap, vUv);\n              // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n              roughnessFactor *= texelRoughness.g;\n            #endif\n          }\n\n          vec3 normalColor = packNormalToRGB(normal);\n          #ifdef USE_MRT\n            float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n            vec4 depthColor = packDepthToRGBA(fragCoordZ);\n            gNormal = vec4(normalColor, roughnessFactor);\n            gDepth = depthColor;\n          #else\n            gl_FragColor = vec4(normalColor, roughnessFactor);\n          #endif\n        }\n      `),\n      toneMapped: false\n    });\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    Object.defineProperty(this, \"glslVersion\", {\n      get() {\n        return \"USE_MRT\" in this.defines ? GLSL3 : null;\n      },\n      set(_) {}\n    });\n  }\n}\nconst vertexShader = /* glsl */\n`\n  varying vec2 vUv;\n\n  void main() {\n    vUv = position.xy * 0.5 + 0.5;\n    gl_Position = vec4(position.xy, 1.0, 1.0);\n  }\n`;\nconst fragmentShader = /* glsl */\n`\n  varying vec2 vUv;\n  uniform sampler2D inputTexture;\n  uniform sampler2D accumulatedTexture;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform sampler2D envMap;\n  uniform mat4 _projectionMatrix;\n  uniform mat4 _inverseProjectionMatrix;\n  uniform mat4 cameraMatrixWorld;\n  uniform float cameraNear;\n  uniform float cameraFar;\n  uniform float rayDistance;\n  uniform float intensity;\n  uniform float maxDepthDifference;\n  uniform float roughnessFade;\n  uniform float maxRoughness;\n  uniform float fade;\n  uniform float thickness;\n  uniform float ior;\n  uniform float samples;\n  uniform float jitter;\n  uniform float jitterRoughness;\n\n  #define INVALID_RAY_COORDS vec2(-1.0);\n\n  #define EARLY_OUT_COLOR vec4(0.0, 0.0, 0.0, 1.0)\n  #define FLOAT_EPSILON 0.00001\n  float nearMinusFar;\n  float nearMulFar;\n  float farMinusNear;\n\n  #include <packing>\n\n  ${helperFunctions}\n\n  vec2 RayMarch(vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference);\n  vec2 BinarySearch(in vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference);\n  float fastGetViewZ(const in float depth);\n  vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness);\n\n  void main() {\n    vec4 depthTexel = textureLod(depthTexture, vUv, 0.0);\n\n    if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) {\n      gl_FragColor = EARLY_OUT_COLOR;\n      return;\n    }\n\n    float unpackedDepth = unpackRGBAToDepth(depthTexel);\n    vec4 normalTexel = textureLod(normalTexture, vUv, 0.0);\n    float roughness = normalTexel.a;\n    float specular = 1.0 - roughness;\n\n    nearMinusFar = cameraNear - cameraFar;\n    nearMulFar = cameraNear * cameraFar;\n    farMinusNear = cameraFar - cameraNear;\n\n    normalTexel.rgb = unpackRGBToNormal(normalTexel.rgb);\n\n    float depth = fastGetViewZ(unpackedDepth);\n    vec3 viewPos = getViewPosition(depth);\n    vec3 viewDir = normalize(viewPos);\n    vec3 viewNormal = normalTexel.xyz;\n    vec3 worldPos = screenSpaceToWorldSpace(vUv, unpackedDepth);\n\n    vec3 jitt=vec3(0.0);\n    if (jitterRoughness != 0.0 || jitter!=0.0){\n      vec3 randomJitter = hash(50.0 * samples * worldPos) - 0.5;\n      float spread= ((2.0 - specular) + roughness * jitterRoughness);\n      float jitterMix = jitter * 0.25 + jitterRoughness * roughness;\n      if (jitterMix > 1.0) jitterMix = 1.0;\n      jitt = mix(vec3(0.0), randomJitter * spread, jitterMix);\n    }\n    \n    viewNormal += jitt;\n    float fresnelFactor = fresnel_dielectric(viewDir, viewNormal, ior);\n    vec3 iblRadiance = getIBLRadiance(-viewDir, viewNormal, 0.0) * fresnelFactor;\n    float lastFrameAlpha = textureLod(accumulatedTexture, vUv, 0.0).a;\n    if (roughness > maxRoughness || (roughness > 1.0 - FLOAT_EPSILON && roughnessFade > 1.0 - FLOAT_EPSILON)) {\n      gl_FragColor=vec4(iblRadiance,lastFrameAlpha);\n      return;\n    }\n    \n    vec3 reflected = reflect(viewDir, viewNormal);\n    vec3 rayDir = reflected *- viewPos.z;\n    vec3 hitPos = viewPos;\n    float rayHitDepthDifference;\n    vec2 coords = RayMarch(rayDir, hitPos, rayHitDepthDifference);\n    if (coords.x == -1.0){\n      gl_FragColor=vec4(iblRadiance, lastFrameAlpha);\n      return;\n    }\n    \n    vec4 SSRTexel = textureLod(inputTexture, coords.xy, 0.0);\n    vec4 SSRTexelReflected = textureLod(accumulatedTexture, coords.xy, 0.0);\n    vec3 SSR = SSRTexel.rgb + SSRTexelReflected.rgb;\n    float roughnessFactor = mix(specular, 1.0, max(0.0, 1.0 - roughnessFade));\n    vec2 coordsNDC = (coords.xy * 2.0 - 1.0);\n    float screenFade = 0.1;\n    float maxDimension = min(1.0, max(abs(coordsNDC.x), abs(coordsNDC.y)));\n    float reflectionIntensity = 1.0 - (max(0.0, maxDimension - screenFade) / (1.0 - screenFade));\n    reflectionIntensity = max(0.0, reflectionIntensity);\n    vec3 finalSSR = mix(iblRadiance, SSR, reflectionIntensity) * roughnessFactor;\n\n    if (fade != 0.0) {\n      vec3 hitWorldPos = screenSpaceToWorldSpace(coords, rayHitDepthDifference);\n      float reflectionDistance = distance(hitWorldPos, worldPos) + 1.0;\n      float opacity = 1.0 / (reflectionDistance * fade * 0.1);\n      if(opacity > 1.0) opacity=1.0;\n      finalSSR *= opacity;\n    }\n\n    finalSSR *= fresnelFactor * intensity;\n    finalSSR = min(vec3(1.0), finalSSR);\n    float alpha = hitPos.z == 1.0 ? 1.0 : SSRTexelReflected.a;\n    alpha = min(lastFrameAlpha, alpha);\n    gl_FragColor = vec4(finalSSR, alpha);\n  }\n\n  vec2 RayMarch(vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference) {\n    dir=normalize(dir);\n    dir *= rayDistance / float(steps);\n    float depth;\n    vec4 projectedCoord;\n    vec4 lastProjectedCoord;\n    float unpackedDepth;\n    vec4 depthTexel;\n\n    for (int i = 0; i < steps; i++) {\n      hitPos += dir;\n      projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);\n      projectedCoord.xy /= projectedCoord.w;\n      projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n\n      #ifndef missedRays\n        if (\n          projectedCoord.x < 0.0 ||\n          projectedCoord.x > 1.0 ||\n          projectedCoord.y < 0.0 ||\n          projectedCoord.y > 1.0\n        ) {\n          return INVALID_RAY_COORDS;\n        }\n      #endif\n\n      depthTexel = textureLod(depthTexture, projectedCoord.xy, 0.0);\n      unpackedDepth = unpackRGBAToDepth(depthTexel);\n      depth = fastGetViewZ(unpackedDepth);\n      rayHitDepthDifference = depth - hitPos.z;\n\n      if (rayHitDepthDifference >= 0.0 && rayHitDepthDifference < thickness){\n        #if refineSteps == 0\n          if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) return INVALID_RAY_COORDS;\n        #else\n          return BinarySearch(dir, hitPos, rayHitDepthDifference);\n        #endif\n      }\n\n      #ifndef missedRays\n        if (hitPos.z > 0.0) return INVALID_RAY_COORDS;\n      #endif\n\n      lastProjectedCoord = projectedCoord;\n    }\n    \n    hitPos.z = 1.0;\n\n    #ifndef missedRays\n      return INVALID_RAY_COORDS;\n    #endif\n\n    rayHitDepthDifference = unpackedDepth;\n\n    return projectedCoord.xy;\n  }\n\n  vec2 BinarySearch(in vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference) {\n    float depth;\n    vec4 projectedCoord;\n    vec2 lastMinProjectedCoordXY;\n    float unpackedDepth;\n    vec4 depthTexel;\n\n    for (int i = 0; i < refineSteps; i++){\n      projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);\n      projectedCoord.xy /= projectedCoord.w;\n      projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n      depthTexel = textureLod(depthTexture, projectedCoord.xy, 0.0);\n      unpackedDepth = unpackRGBAToDepth(depthTexel);\n      depth = fastGetViewZ(unpackedDepth);\n      rayHitDepthDifference = depth - hitPos.z;\n      dir *= 0.5;\n\n      if (rayHitDepthDifference > 0.0) {\n        hitPos -= dir;\n      } else {\n        hitPos += dir;\n      }\n    }\n    \n    if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) return INVALID_RAY_COORDS;\n    if (abs(rayHitDepthDifference) > maxDepthDifference) return INVALID_RAY_COORDS;\n\n    projectedCoord = _projectionMatrix*vec4(hitPos, 1.0);\n    projectedCoord.xy /= projectedCoord.w;\n    projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n    rayHitDepthDifference = unpackedDepth;\n    return projectedCoord.xy;\n  }\n\n  float fastGetViewZ(const in float depth){\n    #ifdef PERSPECTIVE_CAMERA\n      return nearMulFar / (farMinusNear * depth - cameraFar);\n    #else\n      return depth * nearMinusFar - cameraNear;\n    #endif\n  }\n\n  #include <common>\n  #include <cube_uv_reflection_fragment>\n\n  vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness){\n    #if defined(ENVMAP_TYPE_CUBE_UV)\n      vec3 reflectVec = reflect(-viewDir, normal);\n      reflectVec = normalize(mix(reflectVec, normal,roughness * roughness));\n      reflectVec = inverseTransformDirection(reflectVec, viewMatrix);\n      vec4 envMapColor = textureCubeUV(envMap, reflectVec, roughness);\n      return envMapColor.rgb * intensity;\n    #else\n      return vec3(0.0);\n    #endif\n  }\n`;\nclass ReflectionsMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: \"ReflectionsMaterial\",\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        normalTexture: new Uniform(null),\n        depthTexture: new Uniform(null),\n        _projectionMatrix: new Uniform(new Matrix4()),\n        _inverseProjectionMatrix: new Uniform(new Matrix4()),\n        cameraMatrixWorld: new Uniform(new Matrix4()),\n        cameraNear: new Uniform(0),\n        cameraFar: new Uniform(0),\n        rayDistance: new Uniform(0),\n        intensity: new Uniform(0),\n        roughnessFade: new Uniform(0),\n        fade: new Uniform(0),\n        thickness: new Uniform(0),\n        ior: new Uniform(0),\n        maxDepthDifference: new Uniform(0),\n        jitter: new Uniform(0),\n        jitterRoughness: new Uniform(0),\n        maxRoughness: new Uniform(0),\n        samples: new Uniform(0),\n        envMap: new Uniform(null),\n        envMapPosition: new Uniform(new Vector3()),\n        envMapSize: new Uniform(new Vector3()),\n        viewMatrix: new Uniform(new Matrix4())\n      },\n      defines: {\n        steps: 20,\n        refineSteps: 5,\n        CUBEUV_TEXEL_WIDTH: 0,\n        CUBEUV_TEXEL_HEIGHT: 0,\n        CUBEUV_MAX_MIP: 0,\n        vWorldPosition: \"worldPos\"\n      },\n      fragmentShader,\n      vertexShader,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false\n    });\n  }\n}\nconst getVisibleChildren = object => {\n  const queue = [object];\n  const objects = [];\n  while (queue.length !== 0) {\n    const mesh = queue.shift();\n    if (mesh.material) objects.push(mesh);\n    for (const c of mesh.children) {\n      if (c.visible) queue.push(c);\n    }\n  }\n  return objects;\n};\nconst generateCubeUVSize = parameters => {\n  const imageHeight = parameters.envMapCubeUVHeight;\n  if (imageHeight === null) return null;\n  const maxMip = Math.log2(imageHeight) - 2;\n  const texelHeight = 1 / imageHeight;\n  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return {\n    texelWidth,\n    texelHeight,\n    maxMip\n  };\n};\nconst setupEnvMap = (reflectionsMaterial, envMap, envMapCubeUVHeight) => {\n  reflectionsMaterial.uniforms.envMap.value = envMap;\n  const envMapCubeUVSize = generateCubeUVSize({\n    envMapCubeUVHeight\n  });\n  reflectionsMaterial.defines.ENVMAP_TYPE_CUBE_UV = \"\";\n  reflectionsMaterial.defines.CUBEUV_TEXEL_WIDTH = envMapCubeUVSize.texelWidth;\n  reflectionsMaterial.defines.CUBEUV_TEXEL_HEIGHT = envMapCubeUVSize.texelHeight;\n  reflectionsMaterial.defines.CUBEUV_MAX_MIP = envMapCubeUVSize.maxMip + \".0\";\n  reflectionsMaterial.needsUpdate = true;\n};\nconst isWebGL2Available = () => {\n  try {\n    const canvas = document.createElement(\"canvas\");\n    return !!(window.WebGL2RenderingContext && canvas.getContext(\"webgl2\"));\n  } catch (e) {\n    return false;\n  }\n};\nclass ReflectionsPass extends Pass {\n  constructor(ssrEffect, options = {}) {\n    super(\"ReflectionsPass\");\n    this.ssrEffect = void 0;\n    this.cachedMaterials = /* @__PURE__ */new WeakMap();\n    this.USE_MRT = false;\n    this.webgl1DepthPass = null;\n    this.visibleMeshes = [];\n    this.ssrEffect = ssrEffect;\n    this._scene = ssrEffect._scene;\n    this._camera = ssrEffect._camera;\n    this.fullscreenMaterial = new ReflectionsMaterial();\n    if (ssrEffect._camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = \"\";\n    const width = options.width || typeof window !== \"undefined\" ? window.innerWidth : 2e3;\n    const height = options.height || typeof window !== \"undefined\" ? window.innerHeight : 1e3;\n    this.renderTarget = new WebGLRenderTarget(width, height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false\n    });\n    this.renderPass = new RenderPass(this._scene, this._camera);\n    this.USE_MRT = isWebGL2Available();\n    if (this.USE_MRT) {\n      this.gBuffersRenderTarget = new WebGLMultipleRenderTargets(width, height, 2, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter\n      });\n      this.normalTexture = this.gBuffersRenderTarget.texture[0];\n      this.depthTexture = this.gBuffersRenderTarget.texture[1];\n    } else {\n      this.webgl1DepthPass = new DepthPass(this._scene, this._camera);\n      this.webgl1DepthPass.renderTarget.minFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.magFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.texture.minFilter = LinearFilter;\n      this.webgl1DepthPass.renderTarget.texture.magFilter = LinearFilter;\n      this.webgl1DepthPass.setSize(typeof window !== \"undefined\" ? window.innerWidth : 2e3, typeof window !== \"undefined\" ? window.innerHeight : 1e3);\n      this.gBuffersRenderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter\n      });\n      this.normalTexture = this.gBuffersRenderTarget.texture;\n      this.depthTexture = this.webgl1DepthPass.texture;\n    }\n    this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture;\n    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture;\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;\n    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld;\n    this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix;\n    this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse;\n  }\n  setSize(width, height) {\n    this.renderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);\n    this.gBuffersRenderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;\n    this.fullscreenMaterial.needsUpdate = true;\n  }\n  dispose() {\n    this.renderTarget.dispose();\n    this.gBuffersRenderTarget.dispose();\n    this.renderPass.dispose();\n    if (!this.USE_MRT) this.webgl1DepthPass.dispose();\n    this.fullscreenMaterial.dispose();\n    this.normalTexture = null;\n    this.depthTexture = null;\n    this.velocityTexture = null;\n  }\n  keepMaterialMapUpdated(mrtMaterial, originalMaterial, prop, define) {\n    if (this.ssrEffect[define]) {\n      if (originalMaterial[prop] !== mrtMaterial[prop]) {\n        mrtMaterial[prop] = originalMaterial[prop];\n        mrtMaterial.uniforms[prop].value = originalMaterial[prop];\n        if (originalMaterial[prop]) {\n          mrtMaterial.defines[define] = \"\";\n        } else {\n          delete mrtMaterial.defines[define];\n        }\n        mrtMaterial.needsUpdate = true;\n      }\n    } else if (mrtMaterial[prop] !== void 0) {\n      mrtMaterial[prop] = void 0;\n      mrtMaterial.uniforms[prop].value = void 0;\n      delete mrtMaterial.defines[define];\n      mrtMaterial.needsUpdate = true;\n    }\n  }\n  setMRTMaterialInScene() {\n    this.visibleMeshes = getVisibleChildren(this._scene);\n    for (const c of this.visibleMeshes) {\n      if (c.material) {\n        const originalMaterial = c.material;\n        let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c) || [];\n        if (originalMaterial !== cachedOriginalMaterial) {\n          if (mrtMaterial) mrtMaterial.dispose();\n          mrtMaterial = new MRTMaterial();\n          if (this.USE_MRT) mrtMaterial.defines.USE_MRT = \"\";\n          mrtMaterial.normalScale = originalMaterial.normalScale;\n          mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale;\n          const map = originalMaterial.map || originalMaterial.normalMap || originalMaterial.roughnessMap || originalMaterial.metalnessMap;\n          if (map) mrtMaterial.uniforms.uvTransform.value = map.matrix;\n          this.cachedMaterials.set(c, [originalMaterial, mrtMaterial]);\n        }\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, \"normalMap\", \"useNormalMap\");\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, \"roughnessMap\", \"useRoughnessMap\");\n        mrtMaterial.uniforms.roughness.value = this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(c) ? originalMaterial.roughness || 0 : 1e11;\n        c.material = mrtMaterial;\n      }\n    }\n  }\n  unsetMRTMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      var _c$material;\n      if (((_c$material = c.material) == null ? void 0 : _c$material.type) === \"MRTMaterial\") {\n        c.visible = true;\n        const [originalMaterial] = this.cachedMaterials.get(c);\n        c.material = originalMaterial;\n      }\n    }\n  }\n  render(renderer, inputBuffer) {\n    this.setMRTMaterialInScene();\n    renderer.setRenderTarget(this.gBuffersRenderTarget);\n    this.renderPass.render(renderer, this.gBuffersRenderTarget);\n    this.unsetMRTMaterialInScene();\n    if (!this.USE_MRT) this.webgl1DepthPass.renderPass.render(renderer, this.webgl1DepthPass.renderTarget);\n    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture;\n    this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples;\n    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;\n    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;\n    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse);\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n}\nconst defaultSSROptions = {\n  intensity: 1,\n  exponent: 1,\n  distance: 10,\n  fade: 0,\n  roughnessFade: 1,\n  thickness: 10,\n  ior: 1.45,\n  maxRoughness: 1,\n  maxDepthDifference: 10,\n  blend: 0.9,\n  correction: 1,\n  correctionRadius: 1,\n  blur: 0.5,\n  blurKernel: 1,\n  blurSharpness: 10,\n  jitter: 0,\n  jitterRoughness: 0,\n  steps: 20,\n  refineSteps: 5,\n  missedRays: true,\n  useNormalMap: true,\n  useRoughnessMap: true,\n  resolutionScale: 1,\n  velocityResolutionScale: 1\n};\nconst temporalResolve = /* glsl */\n`\n  uniform sampler2D inputTexture;\n  uniform sampler2D accumulatedTexture;\n  uniform sampler2D velocityTexture;\n  uniform sampler2D lastVelocityTexture;\n  uniform float blend;\n  uniform float correction;\n  uniform float exponent;\n  uniform float samples;\n  uniform vec2 invTexSize;\n  uniform mat4 curInverseProjectionMatrix;\n  uniform mat4 curCameraMatrixWorld;\n  uniform mat4 prevInverseProjectionMatrix;\n  uniform mat4 prevCameraMatrixWorld;\n  varying vec2 vUv;\n\n  #define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\n  #define FLOAT_EPSILON 0.00001\n  #define FLOAT_ONE_MINUS_EPSILON 0.99999\n\n  vec3 transformexponent;\n  vec3 undoColorTransformExponent;\n\n  vec3 transformColor(vec3 color) {\n    if (exponent == 1.0) return color;\n    return pow(abs(color), transformexponent);\n  }\n\n  vec3 undoColorTransform(vec3 color) {\n    if (exponent == 1.0) return color;\n    return max(pow(abs(color), undoColorTransformExponent), vec3(0.0));\n  }\n\n  void main() {\n    if (exponent != 1.0){\n      transformexponent = vec3(1.0 / exponent);\n      undoColorTransformExponent = vec3(exponent);\n    }\n\n    vec4 inputTexel = textureLod(inputTexture, vUv, 0.0);\n    vec4 accumulatedTexel;\n    vec3 inputColor = transformColor(inputTexel.rgb);\n    vec3 accumulatedColor;\n    float alpha = inputTexel.a;\n    float velocityDisocclusion;\n    bool didReproject = false;\n\n    #ifdef boxBlur\n      vec3 boxBlurredColor = inputTexel.rgb;\n    #endif\n\n    vec4 velocity = textureLod(velocityTexture, vUv, 0.0);\n    bool isMoving = alpha < 1.0 || dot(velocity.xy, velocity.xy) > 0.0;\n    if (isMoving) {\n      vec3 minNeighborColor = inputColor;\n      vec3 maxNeighborColor = inputColor;\n      vec3 col;\n      vec2 neighborUv;\n      vec2 reprojectedUv = vUv-velocity.xy;\n      vec4 lastVelocity = textureLod(lastVelocityTexture, reprojectedUv, 0.0);\n      float depth = velocity.b;\n      float closestDepth = depth;\n      float lastClosestDepth = lastVelocity.b;\n      float neighborDepth;\n      float lastNeighborDepth;\n\n      for (int x = -correctionRadius; x <= correctionRadius; x++) {\n        for (int y = -correctionRadius; y <= correctionRadius; y++) {\n          if (x != 0 || y != 0) {\n            neighborUv = vUv + vec2(x,y) * invTexSize;\n            vec4 neigborVelocity = textureLod(velocityTexture, neighborUv, 0.0);\n            neighborDepth = neigborVelocity.b;\n            col = textureLod(inputTexture, neighborUv, 0.0).xyz;\n            int absX = abs(x);\n            int absY = abs(y);\n\n            #ifdef dilation\n              if (absX == 1 && absY == 1) {\n                if (neighborDepth > closestDepth) {\n                  velocity=neigborVelocity;\n                  closestDepth=neighborDepth;\n                }\n\n                vec4 lastNeighborVelocity = textureLod(velocityTexture, vUv + vec2(x, y) * invTexSize, 0.0);\n                lastNeighborDepth = lastNeighborVelocity.b;\n\n                if (neighborDepth > closestDepth) {\n                  lastVelocity = lastNeighborVelocity;\n                  lastClosestDepth = lastNeighborDepth;\n                }\n              }\n            #endif\n\n            if (abs(depth-neighborDepth) < MAX_NEIGHBOR_DEPTH_DIFFERENCE) {\n              #ifdef boxBlur\n                if (absX <= 2 && absY <= 2) boxBlurredColor += col;\n              #endif\n\n              col = transformColor(col);\n              minNeighborColor = min(col, minNeighborColor);\n              maxNeighborColor = max(col, maxNeighborColor);\n            }\n          }\n        }\n      }\n\n      float velocityLength = length(lastVelocity.xy - velocity.xy);\n      velocityDisocclusion = (velocityLength - 0.000005) * 10.0;\n      velocityDisocclusion *= velocityDisocclusion;\n      reprojectedUv = vUv - velocity.xy;\n\n      #ifdef boxBlur\n        float pxRadius = correctionRadius > 5 ? 121.0 : pow(float(correctionRadius * 2 + 1), 2.0);\n        boxBlurredColor /= pxRadius;\n        boxBlurredColor = transformColor(boxBlurredColor);\n      #endif\n\n      if (\n        reprojectedUv.x >=0.0 &&\n        reprojectedUv.x <= 1.0 &&\n        reprojectedUv.y >= 0.0 &&\n        reprojectedUv.y <= 1.0\n      ) {\n        accumulatedTexel = textureLod(accumulatedTexture, reprojectedUv, 0.0);\n        accumulatedColor = transformColor(accumulatedTexel.rgb);\n        vec3 clampedColor = clamp(accumulatedColor, minNeighborColor, maxNeighborColor);\n        accumulatedColor = mix(accumulatedColor, clampedColor, correction);\n        didReproject = true;\n      } else {\n        #ifdef boxBlur\n          accumulatedColor=boxBlurredColor;\n        #else\n          accumulatedColor=inputColor;\n        #endif\n      }\n\n      if (velocity.r > FLOAT_ONE_MINUS_EPSILON && velocity.g > FLOAT_ONE_MINUS_EPSILON) {\n        alpha = 0.0;\n        velocityDisocclusion = 1.0;\n      }\n    } else {\n      accumulatedColor = transformColor(textureLod(accumulatedTexture, vUv, 0.0).rgb);\n    }\n\n    vec3 outputColor = inputColor;\n\n    #include <custom_compose_shader>\n\n    gl_FragColor = vec4(undoColorTransform(outputColor), alpha);\n  }\n`;\nclass TemporalResolveMaterial extends ShaderMaterial {\n  constructor(customComposeShader) {\n    const fragmentShader2 = temporalResolve.replace(\"#include <custom_compose_shader>\", customComposeShader);\n    super({\n      type: \"TemporalResolveMaterial\",\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        velocityTexture: new Uniform(null),\n        lastVelocityTexture: new Uniform(null),\n        samples: new Uniform(1),\n        blend: new Uniform(0.5),\n        correction: new Uniform(1),\n        exponent: new Uniform(1),\n        invTexSize: new Uniform(new Vector2())\n      },\n      defines: {\n        correctionRadius: 1\n      },\n      vertexShader,\n      fragmentShader: fragmentShader2\n    });\n  }\n}\nconst prev_skinning_pars_vertex = /* glsl */\n`\n    #ifdef USE_SKINNING\n      #ifdef BONE_TEXTURE\n        uniform sampler2D prevBoneTexture;\n        mat4 getPrevBoneMatrix( const in float i ) {\n          float j = i * 4.0;\n          float x = mod( j, float( boneTextureSize ) );\n          float y = floor( j / float( boneTextureSize ) );\n          float dx = 1.0 / float( boneTextureSize );\n          float dy = 1.0 / float( boneTextureSize );\n          y = dy * ( y + 0.5 );\n          vec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );\n          vec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );\n          vec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );\n          vec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );\n          mat4 bone = mat4( v1, v2, v3, v4 );\n          return bone;\n        }\n      #else\n        uniform mat4 prevBoneMatrices[ MAX_BONES ];\n        mat4 getPrevBoneMatrix( const in float i ) {\n          mat4 bone = prevBoneMatrices[ int(i) ];\n          return bone;\n        }\n      #endif\n    #endif\n`;\nconst velocity_vertex = /* glsl */\n`\n    vec3 transformed;\n\n    // Get the normal\n    ${ShaderChunk.skinbase_vertex}\n    ${ShaderChunk.beginnormal_vertex}\n    ${ShaderChunk.skinnormal_vertex}\n    ${ShaderChunk.defaultnormal_vertex}\n\n    // Get the current vertex position\n    transformed = vec3( position );\n    ${ShaderChunk.skinning_vertex}\n    newPosition = velocityMatrix * vec4( transformed, 1.0 );\n\n    // Get the previous vertex position\n    transformed = vec3( position );\n    ${ShaderChunk.skinbase_vertex.replace(/mat4 /g, \"\").replace(/getBoneMatrix/g, \"getPrevBoneMatrix\")}\n    ${ShaderChunk.skinning_vertex.replace(/vec4 /g, \"\")}\n    prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = newPosition;\n`;\nclass VelocityMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        prevVelocityMatrix: {\n          value: new Matrix4()\n        },\n        velocityMatrix: {\n          value: new Matrix4()\n        },\n        prevBoneTexture: {\n          value: null\n        },\n        interpolateGeometry: {\n          value: 0\n        },\n        intensity: {\n          value: 1\n        },\n        boneTexture: {\n          value: null\n        },\n        alphaTest: {\n          value: 0\n        },\n        map: {\n          value: null\n        },\n        alphaMap: {\n          value: null\n        },\n        opacity: {\n          value: 1\n        }\n      },\n      vertexShader: (/* glsl */\n      `\n                    #define MAX_BONES 1024\n\n                    ${ShaderChunk.skinning_pars_vertex}\n                    ${prev_skinning_pars_vertex}\n\n                    uniform mat4 velocityMatrix;\n                    uniform mat4 prevVelocityMatrix;\n                    uniform float interpolateGeometry;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n          varying vec2 vHighPrecisionZW;\n\n                    void main() {\n\n                        ${velocity_vertex}\n\n            vHighPrecisionZW = gl_Position.zw;\n\n                    }`),\n      fragmentShader: (/* glsl */\n      `\n                    uniform float intensity;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n          varying vec2 vHighPrecisionZW;\n\n                    void main() {\n            #ifdef FULL_MOVEMENT\n            gl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );\n            return;\n            #endif\n\n                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;\n                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;\n\n                        vec2 vel = pos1 - pos0;\n\n            float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );\n\n                    }`)\n    });\n    this.isVelocityMaterial = true;\n  }\n}\nconst backgroundColor = new Color(0);\nconst updateProperties = [\"visible\", \"wireframe\", \"side\"];\nclass VelocityPass extends Pass {\n  constructor(scene, camera) {\n    var _window, _window2;\n    super(\"VelocityPass\");\n    this.cachedMaterials = /* @__PURE__ */new WeakMap();\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion()\n    };\n    this.visibleMeshes = [];\n    this.renderedMeshesThisFrame = 0;\n    this.renderedMeshesLastFrame = 0;\n    this._scene = scene;\n    this._camera = camera;\n    this.renderTarget = new WebGLRenderTarget(((_window = window) == null ? void 0 : _window.innerWidth) || 1e3, ((_window2 = window) == null ? void 0 : _window2.innerHeight) || 1e3, {\n      type: HalfFloatType\n    });\n  }\n  setVelocityMaterialInScene() {\n    this.renderedMeshesThisFrame = 0;\n    this.visibleMeshes = getVisibleChildren(this._scene);\n    for (const c of this.visibleMeshes) {\n      var _c$skeleton2;\n      const originalMaterial = c.material;\n      let [cachedOriginalMaterial, velocityMaterial] = this.cachedMaterials.get(c) || [];\n      if (originalMaterial !== cachedOriginalMaterial) {\n        var _c$skeleton;\n        velocityMaterial = new VelocityMaterial();\n        velocityMaterial.lastMatrixWorld = new Matrix4();\n        c.material = velocityMaterial;\n        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) this.saveBoneTexture(c);\n        this.cachedMaterials.set(c, [originalMaterial, velocityMaterial]);\n      }\n      velocityMaterial.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);\n      if (c.userData.needsUpdatedReflections || originalMaterial.map instanceof VideoTexture) {\n        if (!(\"FULL_MOVEMENT\" in velocityMaterial.defines)) velocityMaterial.needsUpdate = true;\n        velocityMaterial.defines.FULL_MOVEMENT = \"\";\n      } else {\n        if (\"FULL_MOVEMENT\" in velocityMaterial.defines) {\n          delete velocityMaterial.defines.FULL_MOVEMENT;\n          velocityMaterial.needsUpdate = true;\n        }\n      }\n      c.visible = this.cameraMovedThisFrame || !c.matrixWorld.equals(velocityMaterial.lastMatrixWorld) || c.skeleton || \"FULL_MOVEMENT\" in velocityMaterial.defines;\n      c.material = velocityMaterial;\n      if (!c.visible) continue;\n      this.renderedMeshesThisFrame++;\n      for (const prop of updateProperties) velocityMaterial[prop] = originalMaterial[prop];\n      if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) {\n        velocityMaterial.defines.USE_SKINNING = \"\";\n        velocityMaterial.defines.BONE_TEXTURE = \"\";\n        velocityMaterial.uniforms.boneTexture.value = c.skeleton.boneTexture;\n      }\n    }\n  }\n  saveBoneTexture(object) {\n    let boneTexture = object.material.uniforms.prevBoneTexture.value;\n    if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {\n      boneTexture = object.material.uniforms.prevBoneTexture.value;\n      boneTexture.image.data.set(object.skeleton.boneTexture.image.data);\n    } else {\n      var _boneTexture;\n      (_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose();\n      const boneMatrices = object.skeleton.boneTexture.image.data.slice();\n      const size = object.skeleton.boneTexture.image.width;\n      boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n      object.material.uniforms.prevBoneTexture.value = boneTexture;\n      boneTexture.needsUpdate = true;\n    }\n  }\n  unsetVelocityMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      if (c.material.isVelocityMaterial) {\n        var _c$skeleton3;\n        c.visible = true;\n        c.material.lastMatrixWorld.copy(c.matrixWorld);\n        c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);\n        if ((_c$skeleton3 = c.skeleton) != null && _c$skeleton3.boneTexture) this.saveBoneTexture(c);\n        c.material = this.cachedMaterials.get(c)[0];\n      }\n    }\n  }\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height);\n  }\n  renderVelocity(renderer) {\n    renderer.setRenderTarget(this.renderTarget);\n    if (this.renderedMeshesThisFrame > 0) {\n      const {\n        background\n      } = this._scene;\n      this._scene.background = backgroundColor;\n      renderer.render(this._scene, this._camera);\n      this._scene.background = background;\n    } else {\n      renderer.clearColor();\n    }\n  }\n  checkCameraMoved() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));\n    if (moveDist > 1e-6 || rotateDist > 1e-6) {\n      this.lastCameraTransform.position.copy(this._camera.position);\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);\n      return true;\n    }\n    return false;\n  }\n  render(renderer) {\n    this.cameraMovedThisFrame = this.checkCameraMoved();\n    this.setVelocityMaterialInScene();\n    if (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0) this.renderVelocity(renderer);\n    this.unsetVelocityMaterialInScene();\n    this.renderedMeshesLastFrame = this.renderedMeshesThisFrame;\n  }\n}\nconst zeroVec2 = new Vector2();\nclass TemporalResolvePass extends Pass {\n  constructor(scene, camera, customComposeShader, options = {}) {\n    super(\"TemporalResolvePass\");\n    this.velocityPass = null;\n    this.velocityResolutionScale = 1;\n    this.samples = 1;\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion()\n    };\n    this._scene = scene;\n    this._camera = camera;\n    this.renderTarget = new WebGLRenderTarget(1, 1, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false\n    });\n    this.velocityPass = new VelocityPass(scene, camera);\n    this.fullscreenMaterial = new TemporalResolveMaterial(customComposeShader);\n    this.fullscreenMaterial.defines.correctionRadius = options.correctionRadius || 1;\n    if (options.dilation) this.fullscreenMaterial.defines.dilation = \"\";\n    if (options.boxBlur) this.fullscreenMaterial.defines.boxBlur = \"\";\n    this.setupFramebuffers(1, 1);\n    this.checkCanUseSharedVelocityTexture();\n  }\n  dispose() {\n    if (this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture) {\n      delete this._scene.userData.velocityTexture;\n      delete this._scene.userData.lastVelocityTexture;\n    }\n    this.renderTarget.dispose();\n    this.accumulatedTexture.dispose();\n    this.fullscreenMaterial.dispose();\n    this.velocityPass.dispose();\n  }\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height);\n    this.velocityPass.setSize(width * this.velocityResolutionScale, height * this.velocityResolutionScale);\n    this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.velocityPass.renderTarget.texture.needsUpdate = true;\n    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height);\n    this.setupFramebuffers(width, height);\n  }\n  setupFramebuffers(width, height) {\n    if (this.accumulatedTexture) this.accumulatedTexture.dispose();\n    if (this.lastVelocityTexture) this.lastVelocityTexture.dispose();\n    this.accumulatedTexture = new FramebufferTexture(width, height, RGBAFormat);\n    this.accumulatedTexture.minFilter = LinearFilter;\n    this.accumulatedTexture.magFilter = LinearFilter;\n    this.accumulatedTexture.type = HalfFloatType;\n    this.lastVelocityTexture = new FramebufferTexture(width * this.velocityResolutionScale, height * this.velocityResolutionScale, RGBAFormat);\n    this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;\n    this.lastVelocityTexture.type = HalfFloatType;\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture;\n    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;\n    this.fullscreenMaterial.needsUpdate = true;\n  }\n  checkCanUseSharedVelocityTexture() {\n    const canUseSharedVelocityTexture = this._scene.userData.velocityTexture && this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture;\n    if (canUseSharedVelocityTexture) {\n      if (this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture;\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture;\n        this.fullscreenMaterial.needsUpdate = true;\n      }\n    } else {\n      if (this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture;\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;\n        this.fullscreenMaterial.needsUpdate = true;\n        if (!this._scene.userData.velocityTexture) {\n          this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture;\n          this._scene.userData.lastVelocityTexture = this.lastVelocityTexture;\n        }\n      }\n    }\n    return this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value;\n  }\n  checkNeedsResample() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));\n    if (moveDist > 1e-6 || rotateDist > 1e-6) {\n      this.samples = 1;\n      this.lastCameraTransform.position.copy(this._camera.position);\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);\n    }\n  }\n  render(renderer) {\n    this.samples++;\n    this.checkNeedsResample();\n    this.fullscreenMaterial.uniforms.samples.value = this.samples;\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(this.scene, this.camera);\n    renderer.copyFramebufferToTexture(zeroVec2, this.accumulatedTexture);\n    renderer.setRenderTarget(this.velocityPass.renderTarget);\n    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture);\n  }\n}\nconst halton = function halton2(index, base) {\n  let fraction = 1;\n  let result = 0;\n  while (index > 0) {\n    fraction /= base;\n    result += fraction * (index % base);\n    index = ~~(index / base);\n  }\n  return result;\n};\nconst generateHalton23Points = count => {\n  const data = [];\n  let i = 1;\n  const end = i + count;\n  for (; i < end; i++) {\n    data.push([halton(i, 2) - 0.5, halton(i, 3) - 0.5]);\n  }\n  return data;\n};\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nconst worldposReplace = /* glsl */\n`\n#if defined( USE_ENVMAP ) || defined(  ) || defined ( USE_SHADOWMAP )\n    vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n    #ifdef BOX_PROJECTED_ENV_MAP\n        vWorldPosition = worldPosition.xyz;\n    #endif\n#endif\n`;\nconst boxProjectDefinitions = /* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    uniform vec3 envMapSize;\n    uniform vec3 envMapPosition;\n    varying vec3 vWorldPosition;\n\n    vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n        vec3 nDir = normalize( v );\n\n        vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n        vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n\n        vec3 rbminmax;\n\n        rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n        rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n        rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n\n        float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n        vec3 boxIntersection = vWorldPosition + nDir * correction;\n\n        return boxIntersection - cubePos;\n    }\n#endif\n`;\nconst getIBLIrradiance_patch = /* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n`;\nconst getIBLRadiance_patch = /* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n    reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n`;\nfunction useBoxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  shader.defines.BOX_PROJECTED_ENV_MAP = \"\";\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition\n  };\n  shader.uniforms.envMapSize = {\n    value: envMapSize\n  };\n  const line1 = new RegExp(escapeRegExp(\"vec3 worldNormal = inverseTransformDirection ( normal , viewMatrix ) ;\").replaceAll(\" \", \"\\\\s*\"), \"g\");\n  const line2 = new RegExp(escapeRegExp(\"reflectVec = inverseTransformDirection ( reflectVec , viewMatrix ) ;\").replaceAll(\" \", \"\\\\s*\"), \"g\");\n  shader.vertexShader = \"varying vec3 vWorldPosition;\\n\" + shader.vertexShader.replace(\"#include <worldpos_vertex>\", worldposReplace);\n  shader.fragmentShader = boxProjectDefinitions + \"\\n\" + shader.fragmentShader.replace(\"#include <envmap_physical_pars_fragment>\", ShaderChunk.envmap_physical_pars_fragment).replace(line1, `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n                ${getIBLIrradiance_patch}`).replace(line2, `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n                ${getIBLRadiance_patch}`);\n}\nconst noResetSamplesProperties = [\"blur\", \"blurSharpness\", \"blurKernel\"];\nconst defaultCubeRenderTarget = new WebGLCubeRenderTarget(1);\nlet pmremGenerator;\nclass SSREffect extends Effect {\n  /**\n   * @param {THREE.Scene} scene The scene of the SSR effect\n   * @param {THREE.Camera} camera The camera with which SSR is being rendered\n   * @param {SSROptions} [options] The optional options for the SSR effect\n   */\n  constructor(scene, camera, options = defaultSSROptions) {\n    super(\"SSREffect\", finalSSRShader, {\n      type: \"FinalSSRMaterial\",\n      uniforms: /* @__PURE__ */new Map([[\"reflectionsTexture\", new Uniform(null)], [\"blur\", new Uniform(0)], [\"blurSharpness\", new Uniform(0)], [\"blurKernel\", new Uniform(0)]]),\n      defines: /* @__PURE__ */new Map([[\"RENDER_MODE\", \"0\"]])\n    });\n    this.haltonSequence = generateHalton23Points(1024);\n    this.haltonIndex = 0;\n    this.selection = new Selection();\n    this.lastSize = void 0;\n    this.cubeCamera = new CubeCamera(1e-3, 1e3, defaultCubeRenderTarget);\n    this.usingBoxProjectedEnvMap = false;\n    this._scene = scene;\n    this._camera = camera;\n    const trOptions = {\n      boxBlur: true,\n      dilation: true\n    };\n    options = {\n      ...defaultSSROptions,\n      ...options,\n      ...trOptions\n    };\n    this.temporalResolvePass = new TemporalResolvePass(scene, camera, trCompose, options);\n    this.uniforms.get(\"reflectionsTexture\").value = this.temporalResolvePass.renderTarget.texture;\n    this.reflectionsPass = new ReflectionsPass(this, options);\n    this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture;\n    this.lastSize = {\n      width: options.width,\n      height: options.height,\n      resolutionScale: options.resolutionScale,\n      velocityResolutionScale: options.velocityResolutionScale\n    };\n    this.setSize(options.width, options.height);\n    this.makeOptionsReactive(options);\n  }\n  makeOptionsReactive(options) {\n    let needsUpdate = false;\n    const reflectionPassFullscreenMaterialUniforms = this.reflectionsPass.fullscreenMaterial.uniforms;\n    const reflectionPassFullscreenMaterialUniformsKeys = Object.keys(reflectionPassFullscreenMaterialUniforms);\n    for (const key of Object.keys(options)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return options[key];\n        },\n        set(value) {\n          if (options[key] === value && needsUpdate) return;\n          options[key] = value;\n          if (!noResetSamplesProperties.includes(key)) {\n            this.setSize(this.lastSize.width, this.lastSize.height, true);\n          }\n          switch (key) {\n            case \"resolutionScale\":\n              this.setSize(this.lastSize.width, this.lastSize.height);\n              break;\n            case \"velocityResolutionScale\":\n              this.temporalResolvePass.velocityResolutionScale = value;\n              this.setSize(this.lastSize.width, this.lastSize.height, true);\n              break;\n            case \"blur\":\n              this.uniforms.get(\"blur\").value = value;\n              break;\n            case \"blurSharpness\":\n              this.uniforms.get(\"blurSharpness\").value = value;\n              break;\n            case \"blurKernel\":\n              this.uniforms.get(\"blurKernel\").value = value;\n              break;\n            case \"steps\":\n              this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(value);\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n            case \"refineSteps\":\n              this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(value);\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n            case \"missedRays\":\n              if (value) {\n                this.reflectionsPass.fullscreenMaterial.defines.missedRays = \"\";\n              } else {\n                delete this.reflectionsPass.fullscreenMaterial.defines.missedRays;\n              }\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n            case \"correctionRadius\":\n              this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(value);\n              this.temporalResolvePass.fullscreenMaterial.needsUpdate = needsUpdate;\n              break;\n            case \"blend\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = value;\n              break;\n            case \"correction\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = value;\n              break;\n            case \"exponent\":\n              this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = value;\n              break;\n            case \"distance\":\n              reflectionPassFullscreenMaterialUniforms.rayDistance.value = value;\n            default:\n              if (reflectionPassFullscreenMaterialUniformsKeys.includes(key)) {\n                reflectionPassFullscreenMaterialUniforms[key].value = value;\n              }\n          }\n        }\n      });\n      this[key] = options[key];\n    }\n    needsUpdate = true;\n  }\n  setSize(width, height, force = false) {\n    if (!force && width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale && this.velocityResolutionScale === this.lastSize.velocityResolutionScale) return;\n    this.temporalResolvePass.setSize(width, height);\n    this.reflectionsPass.setSize(width, height);\n    this.lastSize = {\n      width,\n      height,\n      resolutionScale: this.resolutionScale,\n      velocityResolutionScale: this.velocityResolutionScale\n    };\n  }\n  generateBoxProjectedEnvMapFallback(renderer, position = new Vector3(), size = new Vector3(), envMapSize = 512) {\n    this.cubeCamera.renderTarget.dispose();\n    this.cubeCamera.renderTarget = new WebGLCubeRenderTarget(envMapSize);\n    this.cubeCamera.position.copy(position);\n    this.cubeCamera.updateMatrixWorld();\n    this.cubeCamera.update(renderer, this._scene);\n    if (!pmremGenerator) {\n      pmremGenerator = new PMREMGenerator(renderer);\n      pmremGenerator.compileCubemapShader();\n    }\n    const envMap = pmremGenerator.fromCubemap(this.cubeCamera.renderTarget.texture).texture;\n    envMap.minFilter = LinearFilter;\n    envMap.magFilter = LinearFilter;\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n    useBoxProjectedEnvMap(reflectionsMaterial, position, size);\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace(\"vec3 worldPos\", \"worldPos\").replace(\"varying vec3 vWorldPosition;\", \"vec3 worldPos;\");\n    reflectionsMaterial.uniforms.envMapPosition.value.copy(position);\n    reflectionsMaterial.uniforms.envMapSize.value.copy(size);\n    setupEnvMap(reflectionsMaterial, envMap, envMapSize);\n    this.usingBoxProjectedEnvMap = true;\n    return envMap;\n  }\n  setIBLRadiance(iblRadiance, renderer) {\n    this._scene.traverse(c => {\n      if (c.material) {\n        var _renderer$properties$;\n        const uniforms = (_renderer$properties$ = renderer.properties.get(c.material)) == null ? void 0 : _renderer$properties$.uniforms;\n        if (uniforms && \"disableIBLRadiance\" in uniforms) {\n          uniforms.disableIBLRadiance.value = iblRadiance;\n        }\n      }\n    });\n  }\n  deleteBoxProjectedEnvMapFallback() {\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n    reflectionsMaterial.uniforms.envMap.value = null;\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace(\"worldPos = \", \"vec3 worldPos = \");\n    delete reflectionsMaterial.defines.BOX_PROJECTED_ENV_MAP;\n    reflectionsMaterial.needsUpdate = true;\n    this.usingBoxProjectedEnvMap = false;\n  }\n  dispose() {\n    super.dispose();\n    this.reflectionsPass.dispose();\n    this.temporalResolvePass.dispose();\n  }\n  update(renderer, inputBuffer) {\n    if (!this.usingBoxProjectedEnvMap && this._scene.environment) {\n      const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;\n      let envMap = null;\n      this._scene.traverse(c => {\n        if (!envMap && c.material && !c.material.envMap) {\n          const properties = renderer.properties.get(c.material);\n          if (\"envMap\" in properties && properties.envMap instanceof Texture) envMap = properties.envMap;\n        }\n      });\n      if (envMap) {\n        const envMapCubeUVHeight = this._scene.environment.image.height;\n        setupEnvMap(reflectionsMaterial, envMap, envMapCubeUVHeight);\n      }\n    }\n    this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length;\n    const [x, y] = this.haltonSequence[this.haltonIndex];\n    const {\n      width,\n      height\n    } = this.lastSize;\n    this.temporalResolvePass.velocityPass.render(renderer);\n    if (this._camera.setViewOffset) this._camera.setViewOffset(width, height, x, y, width, height);\n    this.reflectionsPass.render(renderer, inputBuffer);\n    this.temporalResolvePass.render(renderer);\n    this._camera.clearViewOffset();\n  }\n  static patchDirectEnvIntensity(envMapIntensity = 0) {\n    if (envMapIntensity === 0) {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\"vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\", \"vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) { return vec3(0.0);\");\n    } else {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\"vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\", \"vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness ) * \" + envMapIntensity.toFixed(5) + \";\");\n    }\n  }\n}\nexport { SSREffect, defaultSSROptions };","map":{"version":3,"names":["boxBlur","finalSSRShader","helperFunctions","trCompose","MRTMaterial","ShaderMaterial","constructor","type","defines","USE_UV","TEMPORAL_RESOLVE","uniforms","opacity","Uniform","normalMap","normalScale","Vector2","uvTransform","Matrix3","roughness","roughnessMap","vertexShader","REVISION","replace","fragmentShader","toneMapped","normalMapType","TangentSpaceNormalMap","Object","defineProperty","get","GLSL3","set","_","ReflectionsMaterial","inputTexture","accumulatedTexture","normalTexture","depthTexture","_projectionMatrix","Matrix4","_inverseProjectionMatrix","cameraMatrixWorld","cameraNear","cameraFar","rayDistance","intensity","roughnessFade","fade","thickness","ior","maxDepthDifference","jitter","jitterRoughness","maxRoughness","samples","envMap","envMapPosition","Vector3","envMapSize","viewMatrix","steps","refineSteps","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","vWorldPosition","depthWrite","depthTest","getVisibleChildren","object","queue","objects","length","mesh","shift","material","push","c","children","visible","generateCubeUVSize","parameters","imageHeight","envMapCubeUVHeight","maxMip","Math","log2","texelHeight","texelWidth","max","pow","setupEnvMap","reflectionsMaterial","value","envMapCubeUVSize","ENVMAP_TYPE_CUBE_UV","needsUpdate","isWebGL2Available","canvas","document","createElement","window","WebGL2RenderingContext","getContext","e","ReflectionsPass","Pass","ssrEffect","options","cachedMaterials","WeakMap","USE_MRT","webgl1DepthPass","visibleMeshes","_scene","_camera","fullscreenMaterial","isPerspectiveCamera","PERSPECTIVE_CAMERA","width","innerWidth","height","innerHeight","renderTarget","WebGLRenderTarget","minFilter","LinearFilter","magFilter","HalfFloatType","depthBuffer","renderPass","RenderPass","gBuffersRenderTarget","WebGLMultipleRenderTargets","texture","DepthPass","setSize","temporalResolvePass","matrixWorld","projectionMatrix","projectionMatrixInverse","resolutionScale","dispose","velocityTexture","keepMaterialMapUpdated","mrtMaterial","originalMaterial","prop","define","setMRTMaterialInScene","cachedOriginalMaterial","map","metalnessMap","matrix","selection","size","has","unsetMRTMaterialInScene","_c$material","render","renderer","inputBuffer","setRenderTarget","near","far","copy","matrixWorldInverse","scene","camera","defaultSSROptions","exponent","distance","blend","correction","correctionRadius","blur","blurKernel","blurSharpness","missedRays","useNormalMap","useRoughnessMap","velocityResolutionScale","temporalResolve","TemporalResolveMaterial","customComposeShader","fragmentShader2","lastVelocityTexture","invTexSize","prev_skinning_pars_vertex","velocity_vertex","ShaderChunk","skinbase_vertex","beginnormal_vertex","skinnormal_vertex","defaultnormal_vertex","skinning_vertex","VelocityMaterial","prevVelocityMatrix","velocityMatrix","prevBoneTexture","interpolateGeometry","boneTexture","alphaTest","alphaMap","skinning_pars_vertex","isVelocityMaterial","backgroundColor","Color","updateProperties","VelocityPass","_window","_window2","lastCameraTransform","position","quaternion","Quaternion","renderedMeshesThisFrame","renderedMeshesLastFrame","setVelocityMaterialInScene","_c$skeleton2","velocityMaterial","_c$skeleton","lastMatrixWorld","skeleton","saveBoneTexture","multiplyMatrices","modelViewMatrix","userData","needsUpdatedReflections","VideoTexture","FULL_MOVEMENT","cameraMovedThisFrame","equals","USE_SKINNING","BONE_TEXTURE","image","data","_boneTexture","boneMatrices","slice","DataTexture","RGBAFormat","FloatType","unsetVelocityMaterialInScene","_c$skeleton3","renderVelocity","background","clearColor","checkCameraMoved","moveDist","distanceToSquared","rotateDist","dot","zeroVec2","TemporalResolvePass","velocityPass","dilation","setupFramebuffers","checkCanUseSharedVelocityTexture","NearestFilter","FramebufferTexture","canUseSharedVelocityTexture","checkNeedsResample","copyFramebufferToTexture","halton","halton2","index","base","fraction","result","generateHalton23Points","count","i","end","escapeRegExp","string","worldposReplace","boxProjectDefinitions","getIBLIrradiance_patch","getIBLRadiance_patch","useBoxProjectedEnvMap","shader","BOX_PROJECTED_ENV_MAP","line1","RegExp","replaceAll","line2","envmap_physical_pars_fragment","noResetSamplesProperties","defaultCubeRenderTarget","WebGLCubeRenderTarget","pmremGenerator","SSREffect","Effect","Map","haltonSequence","haltonIndex","Selection","lastSize","cubeCamera","CubeCamera","usingBoxProjectedEnvMap","trOptions","reflectionsPass","makeOptionsReactive","reflectionPassFullscreenMaterialUniforms","reflectionPassFullscreenMaterialUniformsKeys","keys","key","includes","parseInt","round","force","generateBoxProjectedEnvMapFallback","updateMatrixWorld","update","PMREMGenerator","compileCubemapShader","fromCubemap","setIBLRadiance","iblRadiance","traverse","_renderer$properties$","properties","disableIBLRadiance","deleteBoxProjectedEnvMapFallback","environment","Texture","x","y","setViewOffset","clearViewOffset","patchDirectEnvIntensity","envMapIntensity","toFixed"],"sources":["/Users/kasaikazunobu/project/babel/babel-project/node_modules/@react-three/postprocessing/src/effects/SSR/screen-space-reflections.js"],"sourcesContent":["import { Pass, RenderPass, DepthPass, Effect, Selection } from 'postprocessing'\nimport {\n  REVISION,\n  ShaderMaterial,\n  Uniform,\n  Vector2,\n  Matrix3,\n  TangentSpaceNormalMap,\n  GLSL3,\n  Matrix4,\n  Vector3,\n  WebGLRenderTarget,\n  LinearFilter,\n  HalfFloatType,\n  WebGLMultipleRenderTargets,\n  ShaderChunk,\n  Color,\n  Quaternion,\n  VideoTexture,\n  DataTexture,\n  RGBAFormat,\n  FloatType,\n  NearestFilter,\n  FramebufferTexture,\n  WebGLCubeRenderTarget,\n  CubeCamera,\n  PMREMGenerator,\n  Texture,\n} from 'three'\n\nconst boxBlur = /* glsl */ `\n  uniform float blur;\n  uniform float blurSharpness;\n  uniform int blurKernel;\n\n  vec3 denoise(\n    vec3 center,\n    sampler2D tex,\n    vec2 uv,\n    vec2 invTexSize,\n    float blur,\n    float blurSharpness,\n    int blurKernel\n  ) {\n    vec3 color, col;\n    float total, weight;\n\n    for (int x = -blurKernel; x <= blurKernel; x++) {\n      for (int y=-blurKernel; y<=blurKernel; y++) {\n        col = textureLod(tex, uv + vec2(x,y) * invTexSize, 0.0).rgb;\n        weight = 1.0-abs(dot(col - center, vec3(0.25)));\n        weight = pow(weight, blurSharpness);\n        color += col * weight;\n        total += weight;\n      }\n    }\n\n    return color / total;\n  }\n`\n\nconst finalSSRShader = /* glsl */ `\n  #define MODE_DEFAULT 0\n  #define MODE_REFLECTIONS 1\n  #define MODE_RAW_REFLECTION 2\n  #define MODE_BLURRED_REFLECTIONS 3\n  #define MODE_INPUT 4\n  #define MODE_BLUR_MIX 5\n  #define FLOAT_EPSILON 0.00001\n  // uniform sampler2D inputTexture;\n  uniform sampler2D reflectionsTexture;\n  // uniform float samples;\n\n  ${boxBlur}\n\n  void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec4 reflectionsTexel=texture2D(reflectionsTexture, vUv);\n    ivec2 size = textureSize(reflectionsTexture, 0);\n    vec2 invTexSize= 1.0 / vec2(size.x, size.y);\n    vec3 reflectionClr = reflectionsTexel.xyz;\n    if (blur > FLOAT_EPSILON) {\n      vec3 blurredReflectionsColor = denoise(\n        reflectionsTexel.rgb,\n        reflectionsTexture,\n        vUv,\n        invTexSize,\n        blur,\n        blurSharpness,\n        blurKernel\n      );\n      reflectionClr = mix(reflectionClr, blurredReflectionsColor.rgb, blur);\n    }\n\n    #if RENDER_MODE == MODE_DEFAULT\n      outputColor = vec4(inputColor.rgb+reflectionClr, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_REFLECTIONS\n      outputColor = vec4(reflectionClr, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_RAW_REFLECTION\n      outputColor = vec4(reflectionsTexel.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_BLURRED_REFLECTIONS\n      outputColor = vec4(blurredReflectionsTexel.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_INPUT\n      outputColor = vec4(inputColor.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_BLUR_MIX\n      outputColor = vec4(vec3(blur), 1.0);\n    #endif\n  }\n`\n\nconst helperFunctions = /* glsl */ `\n  vec3 getViewPosition(const float depth) {\n    float clipW= _projectionMatrix[2][3] * depth + _projectionMatrix[3][3];\n    vec4 clipPosition = vec4((vec3(vUv, depth) - 0.5) * 2.0, 1.0);\n    clipPosition *= clipW;\n    return(_inverseProjectionMatrix * clipPosition).xyz;\n  }\n\n  float getViewZ(const in float depth) {\n    #ifdef PERSPECTIVE_CAMERA\n      return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    #else\n      return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n    #endif\n  }\n\n  vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){\n    vec4 ndc = vec4((uv.x - 0.5) * 2.0,(uv.y - 0.5)* 2.0, (depth - 0.5) * 2.0, 1.0);\n    vec4 clip= _inverseProjectionMatrix*ndc;\n    vec4 view = cameraMatrixWorld * (clip / clip.w);\n    return view.xyz;\n  }\n\n  #define Scale (vec3(0.8, 0.8, 0.8))\n  #define K (19.19)\n\n  vec3 hash(vec3 a) {\n    a = fract(a * Scale);\n    a += dot(a, a.yxz + K);\n    return fract((a.xxy + a.yxx) * a.zyx);\n  }\n\n  float fresnel_dielectric_cos(float cosi, float eta){\n    float c = abs(cosi);\n    float g = eta * eta - 1.0 +  c* c;\n    float result;\n\n    if (g > 0.0){\n      g = sqrt(g);\n      float A = (g - c) / (g + c);\n      float B = (c* (g + c) - 1.0) / (c * (g - c) + 1.0);\n      result = 0.5 * A * A * (1.0 + B * B);\n    } else {\n      result = 1.0;\n    }\n    \n    return result;\n  }\n\n  float fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta){\n    float cosine = dot(Incoming, Normal);\n    return min(1.0, 5.0 * fresnel_dielectric_cos(cosine, eta));\n  }\n`\n\nconst trCompose = /* glsl */ `\n  #define INV_EULER 0.36787944117144233\n\n  alpha = velocityDisocclusion < FLOAT_EPSILON ? (alpha + 0.0075) : 0.0;\n  alpha = clamp(alpha, 0.0, 1.0);\n  bool needsBlur = !didReproject || velocityDisocclusion > 0.5;\n\n  #ifdef boxBlur\n    if (needsBlur) inputColor = boxBlurredColor;\n  #endif\n\n  if (alpha == 1.0) {\n    outputColor = accumulatedColor;\n  } else {\n    float m = mix(alpha, 1.0, blend);\n    if (needsBlur) m = 0.0;\n    outputColor = accumulatedColor * m + inputColor * (1.0 - m);\n  }\n`\n\n// WebGL2: will render normals to RGB channel of \"gNormal\" buffer, roughness to A channel of \"gNormal\" buffer, depth to RGBA channel of \"gDepth\" buffer\n// and velocity to \"gVelocity\" buffer\n\nclass MRTMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: 'MRTMaterial',\n      defines: {\n        USE_UV: '',\n        TEMPORAL_RESOLVE: '',\n      },\n      uniforms: {\n        opacity: new Uniform(1),\n        normalMap: new Uniform(null),\n        normalScale: new Uniform(new Vector2(1, 1)),\n        uvTransform: new Uniform(new Matrix3()),\n        roughness: new Uniform(1),\n        roughnessMap: new Uniform(null),\n      },\n      vertexShader: /* glsl */ `\n        #ifdef USE_MRT\n          varying vec2 vHighPrecisionZW;\n        #endif\n        #define NORMAL\n        #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n          varying vec3 vViewPosition;\n        #endif\n        #include <common>\n        #include <uv_pars_vertex>\n        #include <displacementmap_pars_vertex>\n        #include <normal_pars_vertex>\n        #include <morphtarget_pars_vertex>\n        #include <skinning_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n        #ifdef USE_UV\n          ${REVISION.replace(/\\D+/g, '') >= 151 ? 'uniform mat3 uvTransform;' : ''}\n        #endif\n        void main() {\n          #include <uv_vertex>\n          #include <beginnormal_vertex>\n          #include <morphnormal_vertex>\n          #include <skinbase_vertex>\n          #include <skinnormal_vertex>\n          #include <defaultnormal_vertex>\n          #include <normal_vertex>\n          #include <begin_vertex>\n          #include <morphtarget_vertex>\n          #include <skinning_vertex>\n          #include <displacementmap_vertex>\n          #include <project_vertex>\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n            vViewPosition = -mvPosition.xyz;\n          #endif\n          #ifdef USE_MRT\n            vHighPrecisionZW = gl_Position.zw;\n          #endif\n          #ifdef USE_UV\n            vUv = (uvTransform * vec3(uv, 1)).xy;\n          #endif\n        }\n      `,\n      fragmentShader: /* glsl */ `\n        #define NORMAL\n        #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n          varying vec3 vViewPosition;\n        #endif\n        #include <packing>\n        #include <uv_pars_fragment>\n        #include <normal_pars_fragment>\n        #include <bumpmap_pars_fragment>\n        #include <normalmap_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n        #include <roughnessmap_pars_fragment>\n\n        #ifdef USE_MRT\n          layout(location = 0) out vec4 gNormal;\n          layout(location = 1) out vec4 gDepth;\n          varying vec2 vHighPrecisionZW;\n        #endif\n        uniform float roughness;\n        void main() {\n          #include <clipping_planes_fragment>\n          #include <logdepthbuf_fragment>\n          #include <normal_fragment_begin>\n          #include <normal_fragment_maps>\n\n          float roughnessFactor = roughness;\n\n          if (roughness > 10.0e9){\n            roughnessFactor = 1.;\n          } else {\n            #ifdef useRoughnessMap\n              vec4 texelRoughness = texture2D(roughnessMap, vUv);\n              // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n              roughnessFactor *= texelRoughness.g;\n            #endif\n          }\n\n          vec3 normalColor = packNormalToRGB(normal);\n          #ifdef USE_MRT\n            float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n            vec4 depthColor = packDepthToRGBA(fragCoordZ);\n            gNormal = vec4(normalColor, roughnessFactor);\n            gDepth = depthColor;\n          #else\n            gl_FragColor = vec4(normalColor, roughnessFactor);\n          #endif\n        }\n      `,\n      toneMapped: false,\n    })\n    this.normalMapType = TangentSpaceNormalMap\n    this.normalScale = new Vector2(1, 1)\n    Object.defineProperty(this, 'glslVersion', {\n      get() {\n        return 'USE_MRT' in this.defines ? GLSL3 : null\n      },\n      set(_) {},\n    })\n  }\n}\n\nconst vertexShader = /* glsl */ `\n  varying vec2 vUv;\n\n  void main() {\n    vUv = position.xy * 0.5 + 0.5;\n    gl_Position = vec4(position.xy, 1.0, 1.0);\n  }\n`\n\nconst fragmentShader = /* glsl */ `\n  varying vec2 vUv;\n  uniform sampler2D inputTexture;\n  uniform sampler2D accumulatedTexture;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform sampler2D envMap;\n  uniform mat4 _projectionMatrix;\n  uniform mat4 _inverseProjectionMatrix;\n  uniform mat4 cameraMatrixWorld;\n  uniform float cameraNear;\n  uniform float cameraFar;\n  uniform float rayDistance;\n  uniform float intensity;\n  uniform float maxDepthDifference;\n  uniform float roughnessFade;\n  uniform float maxRoughness;\n  uniform float fade;\n  uniform float thickness;\n  uniform float ior;\n  uniform float samples;\n  uniform float jitter;\n  uniform float jitterRoughness;\n\n  #define INVALID_RAY_COORDS vec2(-1.0);\n\n  #define EARLY_OUT_COLOR vec4(0.0, 0.0, 0.0, 1.0)\n  #define FLOAT_EPSILON 0.00001\n  float nearMinusFar;\n  float nearMulFar;\n  float farMinusNear;\n\n  #include <packing>\n\n  ${helperFunctions}\n\n  vec2 RayMarch(vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference);\n  vec2 BinarySearch(in vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference);\n  float fastGetViewZ(const in float depth);\n  vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness);\n\n  void main() {\n    vec4 depthTexel = textureLod(depthTexture, vUv, 0.0);\n\n    if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) {\n      gl_FragColor = EARLY_OUT_COLOR;\n      return;\n    }\n\n    float unpackedDepth = unpackRGBAToDepth(depthTexel);\n    vec4 normalTexel = textureLod(normalTexture, vUv, 0.0);\n    float roughness = normalTexel.a;\n    float specular = 1.0 - roughness;\n\n    nearMinusFar = cameraNear - cameraFar;\n    nearMulFar = cameraNear * cameraFar;\n    farMinusNear = cameraFar - cameraNear;\n\n    normalTexel.rgb = unpackRGBToNormal(normalTexel.rgb);\n\n    float depth = fastGetViewZ(unpackedDepth);\n    vec3 viewPos = getViewPosition(depth);\n    vec3 viewDir = normalize(viewPos);\n    vec3 viewNormal = normalTexel.xyz;\n    vec3 worldPos = screenSpaceToWorldSpace(vUv, unpackedDepth);\n\n    vec3 jitt=vec3(0.0);\n    if (jitterRoughness != 0.0 || jitter!=0.0){\n      vec3 randomJitter = hash(50.0 * samples * worldPos) - 0.5;\n      float spread= ((2.0 - specular) + roughness * jitterRoughness);\n      float jitterMix = jitter * 0.25 + jitterRoughness * roughness;\n      if (jitterMix > 1.0) jitterMix = 1.0;\n      jitt = mix(vec3(0.0), randomJitter * spread, jitterMix);\n    }\n    \n    viewNormal += jitt;\n    float fresnelFactor = fresnel_dielectric(viewDir, viewNormal, ior);\n    vec3 iblRadiance = getIBLRadiance(-viewDir, viewNormal, 0.0) * fresnelFactor;\n    float lastFrameAlpha = textureLod(accumulatedTexture, vUv, 0.0).a;\n    if (roughness > maxRoughness || (roughness > 1.0 - FLOAT_EPSILON && roughnessFade > 1.0 - FLOAT_EPSILON)) {\n      gl_FragColor=vec4(iblRadiance,lastFrameAlpha);\n      return;\n    }\n    \n    vec3 reflected = reflect(viewDir, viewNormal);\n    vec3 rayDir = reflected *- viewPos.z;\n    vec3 hitPos = viewPos;\n    float rayHitDepthDifference;\n    vec2 coords = RayMarch(rayDir, hitPos, rayHitDepthDifference);\n    if (coords.x == -1.0){\n      gl_FragColor=vec4(iblRadiance, lastFrameAlpha);\n      return;\n    }\n    \n    vec4 SSRTexel = textureLod(inputTexture, coords.xy, 0.0);\n    vec4 SSRTexelReflected = textureLod(accumulatedTexture, coords.xy, 0.0);\n    vec3 SSR = SSRTexel.rgb + SSRTexelReflected.rgb;\n    float roughnessFactor = mix(specular, 1.0, max(0.0, 1.0 - roughnessFade));\n    vec2 coordsNDC = (coords.xy * 2.0 - 1.0);\n    float screenFade = 0.1;\n    float maxDimension = min(1.0, max(abs(coordsNDC.x), abs(coordsNDC.y)));\n    float reflectionIntensity = 1.0 - (max(0.0, maxDimension - screenFade) / (1.0 - screenFade));\n    reflectionIntensity = max(0.0, reflectionIntensity);\n    vec3 finalSSR = mix(iblRadiance, SSR, reflectionIntensity) * roughnessFactor;\n\n    if (fade != 0.0) {\n      vec3 hitWorldPos = screenSpaceToWorldSpace(coords, rayHitDepthDifference);\n      float reflectionDistance = distance(hitWorldPos, worldPos) + 1.0;\n      float opacity = 1.0 / (reflectionDistance * fade * 0.1);\n      if(opacity > 1.0) opacity=1.0;\n      finalSSR *= opacity;\n    }\n\n    finalSSR *= fresnelFactor * intensity;\n    finalSSR = min(vec3(1.0), finalSSR);\n    float alpha = hitPos.z == 1.0 ? 1.0 : SSRTexelReflected.a;\n    alpha = min(lastFrameAlpha, alpha);\n    gl_FragColor = vec4(finalSSR, alpha);\n  }\n\n  vec2 RayMarch(vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference) {\n    dir=normalize(dir);\n    dir *= rayDistance / float(steps);\n    float depth;\n    vec4 projectedCoord;\n    vec4 lastProjectedCoord;\n    float unpackedDepth;\n    vec4 depthTexel;\n\n    for (int i = 0; i < steps; i++) {\n      hitPos += dir;\n      projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);\n      projectedCoord.xy /= projectedCoord.w;\n      projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n\n      #ifndef missedRays\n        if (\n          projectedCoord.x < 0.0 ||\n          projectedCoord.x > 1.0 ||\n          projectedCoord.y < 0.0 ||\n          projectedCoord.y > 1.0\n        ) {\n          return INVALID_RAY_COORDS;\n        }\n      #endif\n\n      depthTexel = textureLod(depthTexture, projectedCoord.xy, 0.0);\n      unpackedDepth = unpackRGBAToDepth(depthTexel);\n      depth = fastGetViewZ(unpackedDepth);\n      rayHitDepthDifference = depth - hitPos.z;\n\n      if (rayHitDepthDifference >= 0.0 && rayHitDepthDifference < thickness){\n        #if refineSteps == 0\n          if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) return INVALID_RAY_COORDS;\n        #else\n          return BinarySearch(dir, hitPos, rayHitDepthDifference);\n        #endif\n      }\n\n      #ifndef missedRays\n        if (hitPos.z > 0.0) return INVALID_RAY_COORDS;\n      #endif\n\n      lastProjectedCoord = projectedCoord;\n    }\n    \n    hitPos.z = 1.0;\n\n    #ifndef missedRays\n      return INVALID_RAY_COORDS;\n    #endif\n\n    rayHitDepthDifference = unpackedDepth;\n\n    return projectedCoord.xy;\n  }\n\n  vec2 BinarySearch(in vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference) {\n    float depth;\n    vec4 projectedCoord;\n    vec2 lastMinProjectedCoordXY;\n    float unpackedDepth;\n    vec4 depthTexel;\n\n    for (int i = 0; i < refineSteps; i++){\n      projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);\n      projectedCoord.xy /= projectedCoord.w;\n      projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n      depthTexel = textureLod(depthTexture, projectedCoord.xy, 0.0);\n      unpackedDepth = unpackRGBAToDepth(depthTexel);\n      depth = fastGetViewZ(unpackedDepth);\n      rayHitDepthDifference = depth - hitPos.z;\n      dir *= 0.5;\n\n      if (rayHitDepthDifference > 0.0) {\n        hitPos -= dir;\n      } else {\n        hitPos += dir;\n      }\n    }\n    \n    if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) return INVALID_RAY_COORDS;\n    if (abs(rayHitDepthDifference) > maxDepthDifference) return INVALID_RAY_COORDS;\n\n    projectedCoord = _projectionMatrix*vec4(hitPos, 1.0);\n    projectedCoord.xy /= projectedCoord.w;\n    projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n    rayHitDepthDifference = unpackedDepth;\n    return projectedCoord.xy;\n  }\n\n  float fastGetViewZ(const in float depth){\n    #ifdef PERSPECTIVE_CAMERA\n      return nearMulFar / (farMinusNear * depth - cameraFar);\n    #else\n      return depth * nearMinusFar - cameraNear;\n    #endif\n  }\n\n  #include <common>\n  #include <cube_uv_reflection_fragment>\n\n  vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness){\n    #if defined(ENVMAP_TYPE_CUBE_UV)\n      vec3 reflectVec = reflect(-viewDir, normal);\n      reflectVec = normalize(mix(reflectVec, normal,roughness * roughness));\n      reflectVec = inverseTransformDirection(reflectVec, viewMatrix);\n      vec4 envMapColor = textureCubeUV(envMap, reflectVec, roughness);\n      return envMapColor.rgb * intensity;\n    #else\n      return vec3(0.0);\n    #endif\n  }\n`\n\nclass ReflectionsMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: 'ReflectionsMaterial',\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        normalTexture: new Uniform(null),\n        depthTexture: new Uniform(null),\n        _projectionMatrix: new Uniform(new Matrix4()),\n        _inverseProjectionMatrix: new Uniform(new Matrix4()),\n        cameraMatrixWorld: new Uniform(new Matrix4()),\n        cameraNear: new Uniform(0),\n        cameraFar: new Uniform(0),\n        rayDistance: new Uniform(0),\n        intensity: new Uniform(0),\n        roughnessFade: new Uniform(0),\n        fade: new Uniform(0),\n        thickness: new Uniform(0),\n        ior: new Uniform(0),\n        maxDepthDifference: new Uniform(0),\n        jitter: new Uniform(0),\n        jitterRoughness: new Uniform(0),\n        maxRoughness: new Uniform(0),\n        samples: new Uniform(0),\n        envMap: new Uniform(null),\n        envMapPosition: new Uniform(new Vector3()),\n        envMapSize: new Uniform(new Vector3()),\n        viewMatrix: new Uniform(new Matrix4()),\n      },\n      defines: {\n        steps: 20,\n        refineSteps: 5,\n        CUBEUV_TEXEL_WIDTH: 0,\n        CUBEUV_TEXEL_HEIGHT: 0,\n        CUBEUV_MAX_MIP: 0,\n        vWorldPosition: 'worldPos',\n      },\n      fragmentShader,\n      vertexShader,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n    })\n  }\n}\n\nconst getVisibleChildren = (object) => {\n  const queue = [object]\n  const objects = []\n\n  while (queue.length !== 0) {\n    const mesh = queue.shift()\n    if (mesh.material) objects.push(mesh)\n\n    for (const c of mesh.children) {\n      if (c.visible) queue.push(c)\n    }\n  }\n\n  return objects\n}\nconst generateCubeUVSize = (parameters) => {\n  const imageHeight = parameters.envMapCubeUVHeight\n  if (imageHeight === null) return null\n  const maxMip = Math.log2(imageHeight) - 2\n  const texelHeight = 1.0 / imageHeight\n  const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16))\n  return {\n    texelWidth,\n    texelHeight,\n    maxMip,\n  }\n}\nconst setupEnvMap = (reflectionsMaterial, envMap, envMapCubeUVHeight) => {\n  reflectionsMaterial.uniforms.envMap.value = envMap\n  const envMapCubeUVSize = generateCubeUVSize({\n    envMapCubeUVHeight,\n  })\n  reflectionsMaterial.defines.ENVMAP_TYPE_CUBE_UV = ''\n  reflectionsMaterial.defines.CUBEUV_TEXEL_WIDTH = envMapCubeUVSize.texelWidth\n  reflectionsMaterial.defines.CUBEUV_TEXEL_HEIGHT = envMapCubeUVSize.texelHeight\n  reflectionsMaterial.defines.CUBEUV_MAX_MIP = envMapCubeUVSize.maxMip + '.0'\n  reflectionsMaterial.needsUpdate = true\n}\n\nconst isWebGL2Available = () => {\n  try {\n    const canvas = document.createElement('canvas')\n    return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'))\n  } catch (e) {\n    return false\n  }\n}\n\nclass ReflectionsPass extends Pass {\n  constructor(ssrEffect, options = {}) {\n    super('ReflectionsPass')\n    this.ssrEffect = void 0\n    this.cachedMaterials = new WeakMap()\n    this.USE_MRT = false\n    this.webgl1DepthPass = null\n    this.visibleMeshes = []\n    this.ssrEffect = ssrEffect\n    this._scene = ssrEffect._scene\n    this._camera = ssrEffect._camera\n    this.fullscreenMaterial = new ReflectionsMaterial()\n    if (ssrEffect._camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = ''\n    const width = options.width || typeof window !== 'undefined' ? window.innerWidth : 2000\n    const height = options.height || typeof window !== 'undefined' ? window.innerHeight : 1000\n    this.renderTarget = new WebGLRenderTarget(width, height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false,\n    })\n    this.renderPass = new RenderPass(this._scene, this._camera)\n    this.USE_MRT = isWebGL2Available()\n\n    if (this.USE_MRT) {\n      // buffers: normal, depth (2), roughness will be written to the alpha channel of the normal buffer\n      this.gBuffersRenderTarget = new WebGLMultipleRenderTargets(width, height, 2, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n      })\n      this.normalTexture = this.gBuffersRenderTarget.texture[0]\n      this.depthTexture = this.gBuffersRenderTarget.texture[1]\n    } else {\n      // depth pass\n      this.webgl1DepthPass = new DepthPass(this._scene, this._camera)\n      this.webgl1DepthPass.renderTarget.minFilter = LinearFilter\n      this.webgl1DepthPass.renderTarget.magFilter = LinearFilter\n      this.webgl1DepthPass.renderTarget.texture.minFilter = LinearFilter\n      this.webgl1DepthPass.renderTarget.texture.magFilter = LinearFilter\n      this.webgl1DepthPass.setSize(\n        typeof window !== 'undefined' ? window.innerWidth : 2000,\n        typeof window !== 'undefined' ? window.innerHeight : 1000\n      ) // render normals (in the rgb channel) and roughness (in the alpha channel) in gBuffersRenderTarget\n\n      this.gBuffersRenderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n      })\n      this.normalTexture = this.gBuffersRenderTarget.texture\n      this.depthTexture = this.webgl1DepthPass.texture\n    } // set up uniforms\n\n    this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture\n    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture\n    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld\n    this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix\n    this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale)\n    this.gBuffersRenderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale)\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture\n    this.fullscreenMaterial.needsUpdate = true\n  }\n\n  dispose() {\n    this.renderTarget.dispose()\n    this.gBuffersRenderTarget.dispose()\n    this.renderPass.dispose()\n    if (!this.USE_MRT) this.webgl1DepthPass.dispose()\n    this.fullscreenMaterial.dispose()\n    this.normalTexture = null\n    this.depthTexture = null\n    this.velocityTexture = null\n  }\n\n  keepMaterialMapUpdated(mrtMaterial, originalMaterial, prop, define) {\n    if (this.ssrEffect[define]) {\n      if (originalMaterial[prop] !== mrtMaterial[prop]) {\n        mrtMaterial[prop] = originalMaterial[prop]\n        mrtMaterial.uniforms[prop].value = originalMaterial[prop]\n\n        if (originalMaterial[prop]) {\n          mrtMaterial.defines[define] = ''\n        } else {\n          delete mrtMaterial.defines[define]\n        }\n\n        mrtMaterial.needsUpdate = true\n      }\n    } else if (mrtMaterial[prop] !== undefined) {\n      mrtMaterial[prop] = undefined\n      mrtMaterial.uniforms[prop].value = undefined\n      delete mrtMaterial.defines[define]\n      mrtMaterial.needsUpdate = true\n    }\n  }\n\n  setMRTMaterialInScene() {\n    this.visibleMeshes = getVisibleChildren(this._scene)\n\n    for (const c of this.visibleMeshes) {\n      if (c.material) {\n        const originalMaterial = c.material\n        let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c) || []\n\n        if (originalMaterial !== cachedOriginalMaterial) {\n          if (mrtMaterial) mrtMaterial.dispose()\n          mrtMaterial = new MRTMaterial()\n          if (this.USE_MRT) mrtMaterial.defines.USE_MRT = ''\n          mrtMaterial.normalScale = originalMaterial.normalScale\n          mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale\n          const map =\n            originalMaterial.map ||\n            originalMaterial.normalMap ||\n            originalMaterial.roughnessMap ||\n            originalMaterial.metalnessMap\n          if (map) mrtMaterial.uniforms.uvTransform.value = map.matrix\n          this.cachedMaterials.set(c, [originalMaterial, mrtMaterial])\n        } // update the child's MRT material\n\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'normalMap', 'useNormalMap')\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'roughnessMap', 'useRoughnessMap')\n        mrtMaterial.uniforms.roughness.value =\n          this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(c)\n            ? originalMaterial.roughness || 0\n            : 10e10\n        c.material = mrtMaterial\n      }\n    }\n  }\n\n  unsetMRTMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      var _c$material\n\n      if (((_c$material = c.material) == null ? void 0 : _c$material.type) === 'MRTMaterial') {\n        c.visible = true // set material back to the original one\n\n        const [originalMaterial] = this.cachedMaterials.get(c)\n        c.material = originalMaterial\n      }\n    }\n  }\n\n  render(renderer, inputBuffer) {\n    this.setMRTMaterialInScene()\n    renderer.setRenderTarget(this.gBuffersRenderTarget)\n    this.renderPass.render(renderer, this.gBuffersRenderTarget)\n    this.unsetMRTMaterialInScene() // render depth and velocity in seperate passes\n\n    if (!this.USE_MRT) this.webgl1DepthPass.renderPass.render(renderer, this.webgl1DepthPass.renderTarget)\n    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture\n    this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples\n    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near\n    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far\n    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse)\n    renderer.setRenderTarget(this.renderTarget)\n    renderer.render(this.scene, this.camera)\n  }\n}\n\n/**\n * Options of the SSR effect\n * @typedef {Object} SSROptions\n * @property {Number} [intensity] intensity of the reflections\n * @property {Number} [exponent] exponent by which reflections will be potentiated when composing the current frame's reflections and the accumulated reflections into a final reflection; higher values will make reflections clearer by highlighting darker spots less\n * @property {Number} [distance] maximum distance a reflection ray can travel to find what it reflects\n * @property {Number} [fade] how much reflections will fade out by distance\n * @property {Number} [roughnessFade] how intense reflections should be on rough spots; a higher value will make reflections fade out quicker on rough spots\n * @property {Number} [thickness] maximum depth difference between a ray and the particular depth at its screen position before refining with binary search; higher values will result in better performance\n * @property {Number} [ior] Index of Refraction, used for calculating fresnel; reflections tend to be more intense the steeper the angle between them and the viewer is, the ior parameter sets how much the intensity varies\n * @property {Number} [maxRoughness] maximum roughness a texel can have to have reflections calculated for it\n * @property {Number} [maxDepthDifference] maximum depth difference between a ray and the particular depth at its screen position after refining with binary search; higher values will result in better performance\n * @property {Number} [blend] a value between 0 and 1 to set how much the last frame's reflections should be blended in; higher values will result in less noisy reflections when moving the camera but a more smeary look\n * @property {boolean} [correction] how much pixels should be corrected when doing temporal resolving; higher values will result in less smearing but more noise\n * @property {boolean} [correctionRadius] how many surrounding pixels will be used for neighborhood clamping; a higher value can reduce noise when moving the camera but will result in less performance\n * @property {Number} [blur] how much the blurred reflections should be mixed with the raw reflections\n * @property {Number} [blurKernel] kernel size of the Box Blur Filter; higher kernel sizes will result in blurrier reflections with more artifacts\n * @property {Number} [blurSharpness] exponent of the Box Blur filter; higher values will result in more sharpness\n * @property {Number} [jitter] how intense jittering should be\n * @property {Number} [jitterRoughness] how intense jittering should be in relation to a material's roughness\n * @property {Number} [steps] number of steps a reflection ray can maximally do to find an object it intersected (and thus reflects)\n * @property {Number} [refineSteps] once we had our ray intersect something, we need to find the exact point in space it intersected and thus it reflects; this can be done through binary search with the given number of maximum steps\n * @property {boolean} [missedRays] if there should still be reflections for rays for which a reflecting point couldn't be found; enabling this will result in stretched looking reflections which can look good or bad depending on the angle\n * @property {boolean} [useNormalMap] if roughness maps should be taken account of when calculating reflections\n * @property {boolean} [useRoughnessMap] if normal maps should be taken account of when calculating reflections\n * @property {Number} [resolutionScale] resolution of the SSR effect, a resolution of 0.5 means the effect will be rendered at half resolution\n * @property {Number} [velocityResolutionScale] resolution of the velocity buffer, a resolution of 0.5 means velocity will be rendered at half resolution\n */\n\n/**\n * The options of the SSR effect\n * @type {SSROptions}\n */\nconst defaultSSROptions = {\n  intensity: 1,\n  exponent: 1,\n  distance: 10,\n  fade: 0,\n  roughnessFade: 1,\n  thickness: 10,\n  ior: 1.45,\n  maxRoughness: 1,\n  maxDepthDifference: 10,\n  blend: 0.9,\n  correction: 1,\n  correctionRadius: 1,\n  blur: 0.5,\n  blurKernel: 1,\n  blurSharpness: 10,\n  jitter: 0,\n  jitterRoughness: 0,\n  steps: 20,\n  refineSteps: 5,\n  missedRays: true,\n  useNormalMap: true,\n  useRoughnessMap: true,\n  resolutionScale: 1,\n  velocityResolutionScale: 1,\n}\n\nconst temporalResolve = /* glsl */ `\n  uniform sampler2D inputTexture;\n  uniform sampler2D accumulatedTexture;\n  uniform sampler2D velocityTexture;\n  uniform sampler2D lastVelocityTexture;\n  uniform float blend;\n  uniform float correction;\n  uniform float exponent;\n  uniform float samples;\n  uniform vec2 invTexSize;\n  uniform mat4 curInverseProjectionMatrix;\n  uniform mat4 curCameraMatrixWorld;\n  uniform mat4 prevInverseProjectionMatrix;\n  uniform mat4 prevCameraMatrixWorld;\n  varying vec2 vUv;\n\n  #define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\n  #define FLOAT_EPSILON 0.00001\n  #define FLOAT_ONE_MINUS_EPSILON 0.99999\n\n  vec3 transformexponent;\n  vec3 undoColorTransformExponent;\n\n  vec3 transformColor(vec3 color) {\n    if (exponent == 1.0) return color;\n    return pow(abs(color), transformexponent);\n  }\n\n  vec3 undoColorTransform(vec3 color) {\n    if (exponent == 1.0) return color;\n    return max(pow(abs(color), undoColorTransformExponent), vec3(0.0));\n  }\n\n  void main() {\n    if (exponent != 1.0){\n      transformexponent = vec3(1.0 / exponent);\n      undoColorTransformExponent = vec3(exponent);\n    }\n\n    vec4 inputTexel = textureLod(inputTexture, vUv, 0.0);\n    vec4 accumulatedTexel;\n    vec3 inputColor = transformColor(inputTexel.rgb);\n    vec3 accumulatedColor;\n    float alpha = inputTexel.a;\n    float velocityDisocclusion;\n    bool didReproject = false;\n\n    #ifdef boxBlur\n      vec3 boxBlurredColor = inputTexel.rgb;\n    #endif\n\n    vec4 velocity = textureLod(velocityTexture, vUv, 0.0);\n    bool isMoving = alpha < 1.0 || dot(velocity.xy, velocity.xy) > 0.0;\n    if (isMoving) {\n      vec3 minNeighborColor = inputColor;\n      vec3 maxNeighborColor = inputColor;\n      vec3 col;\n      vec2 neighborUv;\n      vec2 reprojectedUv = vUv-velocity.xy;\n      vec4 lastVelocity = textureLod(lastVelocityTexture, reprojectedUv, 0.0);\n      float depth = velocity.b;\n      float closestDepth = depth;\n      float lastClosestDepth = lastVelocity.b;\n      float neighborDepth;\n      float lastNeighborDepth;\n\n      for (int x = -correctionRadius; x <= correctionRadius; x++) {\n        for (int y = -correctionRadius; y <= correctionRadius; y++) {\n          if (x != 0 || y != 0) {\n            neighborUv = vUv + vec2(x,y) * invTexSize;\n            vec4 neigborVelocity = textureLod(velocityTexture, neighborUv, 0.0);\n            neighborDepth = neigborVelocity.b;\n            col = textureLod(inputTexture, neighborUv, 0.0).xyz;\n            int absX = abs(x);\n            int absY = abs(y);\n\n            #ifdef dilation\n              if (absX == 1 && absY == 1) {\n                if (neighborDepth > closestDepth) {\n                  velocity=neigborVelocity;\n                  closestDepth=neighborDepth;\n                }\n\n                vec4 lastNeighborVelocity = textureLod(velocityTexture, vUv + vec2(x, y) * invTexSize, 0.0);\n                lastNeighborDepth = lastNeighborVelocity.b;\n\n                if (neighborDepth > closestDepth) {\n                  lastVelocity = lastNeighborVelocity;\n                  lastClosestDepth = lastNeighborDepth;\n                }\n              }\n            #endif\n\n            if (abs(depth-neighborDepth) < MAX_NEIGHBOR_DEPTH_DIFFERENCE) {\n              #ifdef boxBlur\n                if (absX <= 2 && absY <= 2) boxBlurredColor += col;\n              #endif\n\n              col = transformColor(col);\n              minNeighborColor = min(col, minNeighborColor);\n              maxNeighborColor = max(col, maxNeighborColor);\n            }\n          }\n        }\n      }\n\n      float velocityLength = length(lastVelocity.xy - velocity.xy);\n      velocityDisocclusion = (velocityLength - 0.000005) * 10.0;\n      velocityDisocclusion *= velocityDisocclusion;\n      reprojectedUv = vUv - velocity.xy;\n\n      #ifdef boxBlur\n        float pxRadius = correctionRadius > 5 ? 121.0 : pow(float(correctionRadius * 2 + 1), 2.0);\n        boxBlurredColor /= pxRadius;\n        boxBlurredColor = transformColor(boxBlurredColor);\n      #endif\n\n      if (\n        reprojectedUv.x >=0.0 &&\n        reprojectedUv.x <= 1.0 &&\n        reprojectedUv.y >= 0.0 &&\n        reprojectedUv.y <= 1.0\n      ) {\n        accumulatedTexel = textureLod(accumulatedTexture, reprojectedUv, 0.0);\n        accumulatedColor = transformColor(accumulatedTexel.rgb);\n        vec3 clampedColor = clamp(accumulatedColor, minNeighborColor, maxNeighborColor);\n        accumulatedColor = mix(accumulatedColor, clampedColor, correction);\n        didReproject = true;\n      } else {\n        #ifdef boxBlur\n          accumulatedColor=boxBlurredColor;\n        #else\n          accumulatedColor=inputColor;\n        #endif\n      }\n\n      if (velocity.r > FLOAT_ONE_MINUS_EPSILON && velocity.g > FLOAT_ONE_MINUS_EPSILON) {\n        alpha = 0.0;\n        velocityDisocclusion = 1.0;\n      }\n    } else {\n      accumulatedColor = transformColor(textureLod(accumulatedTexture, vUv, 0.0).rgb);\n    }\n\n    vec3 outputColor = inputColor;\n\n    #include <custom_compose_shader>\n\n    gl_FragColor = vec4(undoColorTransform(outputColor), alpha);\n  }\n`\n\nclass TemporalResolveMaterial extends ShaderMaterial {\n  constructor(customComposeShader) {\n    const fragmentShader = temporalResolve.replace('#include <custom_compose_shader>', customComposeShader)\n    super({\n      type: 'TemporalResolveMaterial',\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        velocityTexture: new Uniform(null),\n        lastVelocityTexture: new Uniform(null),\n        samples: new Uniform(1),\n        blend: new Uniform(0.5),\n        correction: new Uniform(1),\n        exponent: new Uniform(1),\n        invTexSize: new Uniform(new Vector2()),\n      },\n      defines: {\n        correctionRadius: 1,\n      },\n      vertexShader,\n      fragmentShader,\n    })\n  }\n}\n\n// this shader is from: https://github.com/gkjohnson/threejs-sandbox\n// a second set of bone information from the previou frame\n\nconst prev_skinning_pars_vertex =\n  /* glsl */\n  `\n    #ifdef USE_SKINNING\n      #ifdef BONE_TEXTURE\n        uniform sampler2D prevBoneTexture;\n        mat4 getPrevBoneMatrix( const in float i ) {\n          float j = i * 4.0;\n          float x = mod( j, float( boneTextureSize ) );\n          float y = floor( j / float( boneTextureSize ) );\n          float dx = 1.0 / float( boneTextureSize );\n          float dy = 1.0 / float( boneTextureSize );\n          y = dy * ( y + 0.5 );\n          vec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );\n          vec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );\n          vec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );\n          vec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );\n          mat4 bone = mat4( v1, v2, v3, v4 );\n          return bone;\n        }\n      #else\n        uniform mat4 prevBoneMatrices[ MAX_BONES ];\n        mat4 getPrevBoneMatrix( const in float i ) {\n          mat4 bone = prevBoneMatrices[ int(i) ];\n          return bone;\n        }\n      #endif\n    #endif\n` // Returns the body of the vertex shader for the velocity buffer and\n// outputs the position of the current and last frame positions\n\nconst velocity_vertex =\n  /* glsl */\n  `\n    vec3 transformed;\n\n    // Get the normal\n    ${ShaderChunk.skinbase_vertex}\n    ${ShaderChunk.beginnormal_vertex}\n    ${ShaderChunk.skinnormal_vertex}\n    ${ShaderChunk.defaultnormal_vertex}\n\n    // Get the current vertex position\n    transformed = vec3( position );\n    ${ShaderChunk.skinning_vertex}\n    newPosition = velocityMatrix * vec4( transformed, 1.0 );\n\n    // Get the previous vertex position\n    transformed = vec3( position );\n    ${ShaderChunk.skinbase_vertex.replace(/mat4 /g, '').replace(/getBoneMatrix/g, 'getPrevBoneMatrix')}\n    ${ShaderChunk.skinning_vertex.replace(/vec4 /g, '')}\n    prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = newPosition;\n`\nclass VelocityMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        prevVelocityMatrix: {\n          value: new Matrix4(),\n        },\n        velocityMatrix: {\n          value: new Matrix4(),\n        },\n        prevBoneTexture: {\n          value: null,\n        },\n        interpolateGeometry: {\n          value: 0,\n        },\n        intensity: {\n          value: 1,\n        },\n        boneTexture: {\n          value: null,\n        },\n        alphaTest: {\n          value: 0.0,\n        },\n        map: {\n          value: null,\n        },\n        alphaMap: {\n          value: null,\n        },\n        opacity: {\n          value: 1.0,\n        },\n      },\n      vertexShader:\n        /* glsl */\n        `\n                    #define MAX_BONES 1024\n\n                    ${ShaderChunk.skinning_pars_vertex}\n                    ${prev_skinning_pars_vertex}\n\n                    uniform mat4 velocityMatrix;\n                    uniform mat4 prevVelocityMatrix;\n                    uniform float interpolateGeometry;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n          varying vec2 vHighPrecisionZW;\n\n                    void main() {\n\n                        ${velocity_vertex}\n\n            vHighPrecisionZW = gl_Position.zw;\n\n                    }`,\n      fragmentShader:\n        /* glsl */\n        `\n                    uniform float intensity;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n          varying vec2 vHighPrecisionZW;\n\n                    void main() {\n            #ifdef FULL_MOVEMENT\n            gl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );\n            return;\n            #endif\n\n                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;\n                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;\n\n                        vec2 vel = pos1 - pos0;\n\n            float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );\n\n                    }`,\n    })\n    this.isVelocityMaterial = true\n  }\n}\n\nconst backgroundColor = new Color(0)\nconst updateProperties = ['visible', 'wireframe', 'side']\nclass VelocityPass extends Pass {\n  constructor(scene, camera) {\n    var _window, _window2\n\n    super('VelocityPass')\n    this.cachedMaterials = new WeakMap()\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion(),\n    }\n    this.visibleMeshes = []\n    this.renderedMeshesThisFrame = 0\n    this.renderedMeshesLastFrame = 0\n    this._scene = scene\n    this._camera = camera\n    this.renderTarget = new WebGLRenderTarget(\n      ((_window = window) == null ? void 0 : _window.innerWidth) || 1000,\n      ((_window2 = window) == null ? void 0 : _window2.innerHeight) || 1000,\n      {\n        type: HalfFloatType,\n      }\n    )\n  }\n\n  setVelocityMaterialInScene() {\n    this.renderedMeshesThisFrame = 0\n    this.visibleMeshes = getVisibleChildren(this._scene)\n\n    for (const c of this.visibleMeshes) {\n      var _c$skeleton2\n\n      const originalMaterial = c.material\n      let [cachedOriginalMaterial, velocityMaterial] = this.cachedMaterials.get(c) || []\n\n      if (originalMaterial !== cachedOriginalMaterial) {\n        var _c$skeleton\n\n        velocityMaterial = new VelocityMaterial()\n        velocityMaterial.lastMatrixWorld = new Matrix4()\n        c.material = velocityMaterial\n        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) this.saveBoneTexture(c)\n        this.cachedMaterials.set(c, [originalMaterial, velocityMaterial])\n      }\n\n      velocityMaterial.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix)\n\n      if (c.userData.needsUpdatedReflections || originalMaterial.map instanceof VideoTexture) {\n        if (!('FULL_MOVEMENT' in velocityMaterial.defines)) velocityMaterial.needsUpdate = true\n        velocityMaterial.defines.FULL_MOVEMENT = ''\n      } else {\n        if ('FULL_MOVEMENT' in velocityMaterial.defines) {\n          delete velocityMaterial.defines.FULL_MOVEMENT\n          velocityMaterial.needsUpdate = true\n        }\n      }\n\n      c.visible =\n        this.cameraMovedThisFrame ||\n        !c.matrixWorld.equals(velocityMaterial.lastMatrixWorld) ||\n        c.skeleton ||\n        'FULL_MOVEMENT' in velocityMaterial.defines\n      c.material = velocityMaterial\n      if (!c.visible) continue\n      this.renderedMeshesThisFrame++\n\n      for (const prop of updateProperties) velocityMaterial[prop] = originalMaterial[prop]\n\n      if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) {\n        velocityMaterial.defines.USE_SKINNING = ''\n        velocityMaterial.defines.BONE_TEXTURE = ''\n        velocityMaterial.uniforms.boneTexture.value = c.skeleton.boneTexture\n      }\n    }\n  }\n\n  saveBoneTexture(object) {\n    let boneTexture = object.material.uniforms.prevBoneTexture.value\n\n    if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {\n      boneTexture = object.material.uniforms.prevBoneTexture.value\n      boneTexture.image.data.set(object.skeleton.boneTexture.image.data)\n    } else {\n      var _boneTexture\n      ;(_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose()\n      const boneMatrices = object.skeleton.boneTexture.image.data.slice()\n      const size = object.skeleton.boneTexture.image.width\n      boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType)\n      object.material.uniforms.prevBoneTexture.value = boneTexture\n      boneTexture.needsUpdate = true\n    }\n  }\n\n  unsetVelocityMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      if (c.material.isVelocityMaterial) {\n        var _c$skeleton3\n\n        c.visible = true\n        c.material.lastMatrixWorld.copy(c.matrixWorld)\n        c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix)\n        if ((_c$skeleton3 = c.skeleton) != null && _c$skeleton3.boneTexture) this.saveBoneTexture(c)\n        c.material = this.cachedMaterials.get(c)[0]\n      }\n    }\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height)\n  }\n\n  renderVelocity(renderer) {\n    renderer.setRenderTarget(this.renderTarget)\n\n    if (this.renderedMeshesThisFrame > 0) {\n      const { background } = this._scene\n      this._scene.background = backgroundColor\n      renderer.render(this._scene, this._camera)\n      this._scene.background = background\n    } else {\n      renderer.clearColor()\n    }\n  }\n\n  checkCameraMoved() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position)\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion))\n\n    if (moveDist > 0.000001 || rotateDist > 0.000001) {\n      this.lastCameraTransform.position.copy(this._camera.position)\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion)\n      return true\n    }\n\n    return false\n  }\n\n  render(renderer) {\n    this.cameraMovedThisFrame = this.checkCameraMoved()\n    this.setVelocityMaterialInScene()\n    if (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0) this.renderVelocity(renderer)\n    this.unsetVelocityMaterialInScene()\n    this.renderedMeshesLastFrame = this.renderedMeshesThisFrame\n  }\n}\n\nconst zeroVec2 = new Vector2() // the following variables can be accessed by the custom compose shader:\n// \"inputTexel\", \"accumulatedTexel\", \"inputColor\", \"accumulatedColor\", \"alpha\", \"velocityDisocclusion\", \"didReproject\", \"boxBlurredColor\" (if using box blur)\n// the custom compose shader will write the final color to the variable \"outputColor\"\n\nclass TemporalResolvePass extends Pass {\n  constructor(scene, camera, customComposeShader, options = {}) {\n    super('TemporalResolvePass')\n    this.velocityPass = null\n    this.velocityResolutionScale = 1\n    this.samples = 1\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion(),\n    }\n    this._scene = scene\n    this._camera = camera\n    this.renderTarget = new WebGLRenderTarget(1, 1, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false,\n    })\n    this.velocityPass = new VelocityPass(scene, camera)\n    this.fullscreenMaterial = new TemporalResolveMaterial(customComposeShader)\n    this.fullscreenMaterial.defines.correctionRadius = options.correctionRadius || 1\n    if (options.dilation) this.fullscreenMaterial.defines.dilation = ''\n    if (options.boxBlur) this.fullscreenMaterial.defines.boxBlur = ''\n    this.setupFramebuffers(1, 1)\n    this.checkCanUseSharedVelocityTexture()\n  }\n\n  dispose() {\n    if (this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture) {\n      delete this._scene.userData.velocityTexture\n      delete this._scene.userData.lastVelocityTexture\n    }\n\n    this.renderTarget.dispose()\n    this.accumulatedTexture.dispose()\n    this.fullscreenMaterial.dispose()\n    this.velocityPass.dispose()\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height)\n    this.velocityPass.setSize(width * this.velocityResolutionScale, height * this.velocityResolutionScale)\n    this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter\n    this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter\n    this.velocityPass.renderTarget.texture.needsUpdate = true\n    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height)\n    this.setupFramebuffers(width, height)\n  }\n\n  setupFramebuffers(width, height) {\n    if (this.accumulatedTexture) this.accumulatedTexture.dispose()\n    if (this.lastVelocityTexture) this.lastVelocityTexture.dispose()\n    this.accumulatedTexture = new FramebufferTexture(width, height, RGBAFormat)\n    this.accumulatedTexture.minFilter = LinearFilter\n    this.accumulatedTexture.magFilter = LinearFilter\n    this.accumulatedTexture.type = HalfFloatType\n    this.lastVelocityTexture = new FramebufferTexture(\n      width * this.velocityResolutionScale,\n      height * this.velocityResolutionScale,\n      RGBAFormat\n    )\n    this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter\n    this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter\n    this.lastVelocityTexture.type = HalfFloatType\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture\n    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture\n    this.fullscreenMaterial.needsUpdate = true\n  }\n\n  checkCanUseSharedVelocityTexture() {\n    const canUseSharedVelocityTexture =\n      this._scene.userData.velocityTexture &&\n      this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture\n\n    if (canUseSharedVelocityTexture) {\n      // let's use the shared one instead\n      if (this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture\n        this.fullscreenMaterial.needsUpdate = true\n      }\n    } else {\n      // let's stop using the shared one (if used) and mark ours as the shared one instead\n      if (this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture\n        this.fullscreenMaterial.needsUpdate = true\n\n        if (!this._scene.userData.velocityTexture) {\n          this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture\n          this._scene.userData.lastVelocityTexture = this.lastVelocityTexture\n        }\n      }\n    }\n\n    return this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value\n  }\n\n  checkNeedsResample() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position)\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion))\n\n    if (moveDist > 0.000001 || rotateDist > 0.000001) {\n      this.samples = 1\n      this.lastCameraTransform.position.copy(this._camera.position)\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion)\n    }\n  }\n\n  render(renderer) {\n    this.samples++\n    this.checkNeedsResample()\n    this.fullscreenMaterial.uniforms.samples.value = this.samples // const isUsingSharedVelocityTexture = this.checkCanUseSharedVelocityTexture()\n    // if (!isUsingSharedVelocityTexture) this.velocityPass.render(renderer)\n\n    renderer.setRenderTarget(this.renderTarget)\n    renderer.render(this.scene, this.camera) // save the render target's texture for use in next frame\n\n    renderer.copyFramebufferToTexture(zeroVec2, this.accumulatedTexture)\n    renderer.setRenderTarget(this.velocityPass.renderTarget)\n    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture)\n  }\n}\n\n// source: https://observablehq.com/@jrus/halton\nconst halton = function halton(index, base) {\n  let fraction = 1\n  let result = 0\n\n  while (index > 0) {\n    fraction /= base\n    result += fraction * (index % base)\n    index = ~~(index / base) // floor division\n  }\n\n  return result\n} // generates Halton tuples in the range [-0.5:0.5]\n\nconst generateHalton23Points = (count) => {\n  const data = []\n  let i = 1\n  const end = i + count\n\n  for (; i < end; i++) {\n    data.push([halton(i, 2) - 0.5, halton(i, 3) - 0.5])\n  }\n\n  return data\n}\n\n/* eslint-disable camelcase */\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n} // credits for the box-projecting shader code go to codercat (https://codercat.tk)\n\nconst worldposReplace =\n  /* glsl */\n  `\n#if defined( USE_ENVMAP ) || defined(  ) || defined ( USE_SHADOWMAP )\n    vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n    #ifdef BOX_PROJECTED_ENV_MAP\n        vWorldPosition = worldPosition.xyz;\n    #endif\n#endif\n`\nconst boxProjectDefinitions =\n  /* glsl */\n  `\n#ifdef BOX_PROJECTED_ENV_MAP\n    uniform vec3 envMapSize;\n    uniform vec3 envMapPosition;\n    varying vec3 vWorldPosition;\n\n    vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n        vec3 nDir = normalize( v );\n\n        vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n        vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n\n        vec3 rbminmax;\n\n        rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n        rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n        rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n\n        float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n        vec3 boxIntersection = vWorldPosition + nDir * correction;\n\n        return boxIntersection - cubePos;\n    }\n#endif\n` // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nconst getIBLIrradiance_patch =\n  /* glsl */\n  `\n#ifdef BOX_PROJECTED_ENV_MAP\n    worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n` // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nconst getIBLRadiance_patch =\n  /* glsl */\n  `\n#ifdef BOX_PROJECTED_ENV_MAP\n    reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n`\nfunction useBoxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  // defines\n  shader.defines.BOX_PROJECTED_ENV_MAP = '' // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition,\n  }\n  shader.uniforms.envMapSize = {\n    value: envMapSize,\n  }\n  const line1 = new RegExp(\n    escapeRegExp('vec3 worldNormal = inverseTransformDirection ( normal , viewMatrix ) ;').replaceAll(' ', '\\\\s*'),\n    'g'\n  )\n  const line2 = new RegExp(\n    escapeRegExp('reflectVec = inverseTransformDirection ( reflectVec , viewMatrix ) ;').replaceAll(' ', '\\\\s*'),\n    'g'\n  ) // vertex shader\n\n  shader.vertexShader =\n    'varying vec3 vWorldPosition;\\n' + shader.vertexShader.replace('#include <worldpos_vertex>', worldposReplace) // fragment shader\n\n  shader.fragmentShader =\n    boxProjectDefinitions +\n    '\\n' +\n    shader.fragmentShader\n      .replace('#include <envmap_physical_pars_fragment>', ShaderChunk.envmap_physical_pars_fragment)\n      .replace(\n        line1,\n        `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n                ${getIBLIrradiance_patch}`\n      )\n      .replace(\n        line2,\n        `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n                ${getIBLRadiance_patch}`\n      )\n}\n\nconst noResetSamplesProperties = ['blur', 'blurSharpness', 'blurKernel']\nconst defaultCubeRenderTarget = new WebGLCubeRenderTarget(1)\nlet pmremGenerator\nclass SSREffect extends Effect {\n  /**\n   * @param {THREE.Scene} scene The scene of the SSR effect\n   * @param {THREE.Camera} camera The camera with which SSR is being rendered\n   * @param {SSROptions} [options] The optional options for the SSR effect\n   */\n  constructor(scene, camera, options = defaultSSROptions) {\n    super('SSREffect', finalSSRShader, {\n      type: 'FinalSSRMaterial',\n      uniforms: new Map([\n        ['reflectionsTexture', new Uniform(null)],\n        ['blur', new Uniform(0)],\n        ['blurSharpness', new Uniform(0)],\n        ['blurKernel', new Uniform(0)],\n      ]),\n      defines: new Map([['RENDER_MODE', '0']]),\n    })\n    this.haltonSequence = generateHalton23Points(1024)\n    this.haltonIndex = 0\n    this.selection = new Selection()\n    this.lastSize = void 0\n    this.cubeCamera = new CubeCamera(0.001, 1000, defaultCubeRenderTarget)\n    this.usingBoxProjectedEnvMap = false\n    this._scene = scene\n    this._camera = camera\n    const trOptions = {\n      boxBlur: true,\n      dilation: true,\n    }\n    options = { ...defaultSSROptions, ...options, ...trOptions } // set up passes\n    // temporal resolve pass\n\n    this.temporalResolvePass = new TemporalResolvePass(scene, camera, trCompose, options)\n    this.uniforms.get('reflectionsTexture').value = this.temporalResolvePass.renderTarget.texture // reflections pass\n\n    this.reflectionsPass = new ReflectionsPass(this, options)\n    this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture\n    this.lastSize = {\n      width: options.width,\n      height: options.height,\n      resolutionScale: options.resolutionScale,\n      velocityResolutionScale: options.velocityResolutionScale,\n    }\n    this.setSize(options.width, options.height)\n    this.makeOptionsReactive(options)\n  }\n\n  makeOptionsReactive(options) {\n    let needsUpdate = false\n    const reflectionPassFullscreenMaterialUniforms = this.reflectionsPass.fullscreenMaterial.uniforms\n    const reflectionPassFullscreenMaterialUniformsKeys = Object.keys(reflectionPassFullscreenMaterialUniforms)\n\n    for (const key of Object.keys(options)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return options[key]\n        },\n\n        set(value) {\n          if (options[key] === value && needsUpdate) return\n          options[key] = value\n\n          if (!noResetSamplesProperties.includes(key)) {\n            this.setSize(this.lastSize.width, this.lastSize.height, true)\n          }\n\n          switch (key) {\n            case 'resolutionScale':\n              this.setSize(this.lastSize.width, this.lastSize.height)\n              break\n\n            case 'velocityResolutionScale':\n              this.temporalResolvePass.velocityResolutionScale = value\n              this.setSize(this.lastSize.width, this.lastSize.height, true)\n              break\n\n            case 'blur':\n              this.uniforms.get('blur').value = value\n              break\n\n            case 'blurSharpness':\n              this.uniforms.get('blurSharpness').value = value\n              break\n\n            case 'blurKernel':\n              this.uniforms.get('blurKernel').value = value\n              break\n            // defines\n\n            case 'steps':\n              this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(value)\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate\n              break\n\n            case 'refineSteps':\n              this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(value)\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate\n              break\n\n            case 'missedRays':\n              if (value) {\n                this.reflectionsPass.fullscreenMaterial.defines.missedRays = ''\n              } else {\n                delete this.reflectionsPass.fullscreenMaterial.defines.missedRays\n              }\n\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate\n              break\n\n            case 'correctionRadius':\n              this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(value)\n              this.temporalResolvePass.fullscreenMaterial.needsUpdate = needsUpdate\n              break\n\n            case 'blend':\n              this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = value\n              break\n\n            case 'correction':\n              this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = value\n              break\n\n            case 'exponent':\n              this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = value\n              break\n\n            case 'distance':\n              reflectionPassFullscreenMaterialUniforms.rayDistance.value = value\n            // must be a uniform\n\n            default:\n              if (reflectionPassFullscreenMaterialUniformsKeys.includes(key)) {\n                reflectionPassFullscreenMaterialUniforms[key].value = value\n              }\n          }\n        },\n      }) // apply all uniforms and defines\n\n      this[key] = options[key]\n    }\n\n    needsUpdate = true\n  }\n\n  setSize(width, height, force = false) {\n    if (\n      !force &&\n      width === this.lastSize.width &&\n      height === this.lastSize.height &&\n      this.resolutionScale === this.lastSize.resolutionScale &&\n      this.velocityResolutionScale === this.lastSize.velocityResolutionScale\n    )\n      return\n    this.temporalResolvePass.setSize(width, height)\n    this.reflectionsPass.setSize(width, height)\n    this.lastSize = {\n      width,\n      height,\n      resolutionScale: this.resolutionScale,\n      velocityResolutionScale: this.velocityResolutionScale,\n    }\n  }\n\n  generateBoxProjectedEnvMapFallback(renderer, position = new Vector3(), size = new Vector3(), envMapSize = 512) {\n    this.cubeCamera.renderTarget.dispose()\n    this.cubeCamera.renderTarget = new WebGLCubeRenderTarget(envMapSize)\n    this.cubeCamera.position.copy(position)\n    this.cubeCamera.updateMatrixWorld()\n    this.cubeCamera.update(renderer, this._scene)\n\n    if (!pmremGenerator) {\n      pmremGenerator = new PMREMGenerator(renderer)\n      pmremGenerator.compileCubemapShader()\n    }\n\n    const envMap = pmremGenerator.fromCubemap(this.cubeCamera.renderTarget.texture).texture\n    envMap.minFilter = LinearFilter\n    envMap.magFilter = LinearFilter\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useBoxProjectedEnvMap(reflectionsMaterial, position, size)\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader\n      .replace('vec3 worldPos', 'worldPos')\n      .replace('varying vec3 vWorldPosition;', 'vec3 worldPos;')\n    reflectionsMaterial.uniforms.envMapPosition.value.copy(position)\n    reflectionsMaterial.uniforms.envMapSize.value.copy(size)\n    setupEnvMap(reflectionsMaterial, envMap, envMapSize)\n    this.usingBoxProjectedEnvMap = true\n    return envMap\n  }\n\n  setIBLRadiance(iblRadiance, renderer) {\n    this._scene.traverse((c) => {\n      if (c.material) {\n        var _renderer$properties$\n\n        const uniforms =\n          (_renderer$properties$ = renderer.properties.get(c.material)) == null\n            ? void 0\n            : _renderer$properties$.uniforms\n\n        if (uniforms && 'disableIBLRadiance' in uniforms) {\n          uniforms.disableIBLRadiance.value = iblRadiance\n        }\n      }\n    })\n  }\n\n  deleteBoxProjectedEnvMapFallback() {\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial\n    reflectionsMaterial.uniforms.envMap.value = null\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace('worldPos = ', 'vec3 worldPos = ')\n    delete reflectionsMaterial.defines.BOX_PROJECTED_ENV_MAP\n    reflectionsMaterial.needsUpdate = true\n    this.usingBoxProjectedEnvMap = false\n  }\n\n  dispose() {\n    super.dispose()\n    this.reflectionsPass.dispose()\n    this.temporalResolvePass.dispose()\n  }\n\n  update(renderer, inputBuffer) {\n    if (!this.usingBoxProjectedEnvMap && this._scene.environment) {\n      const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial\n      let envMap = null // not sure if there is a cleaner way to find the internal texture of a CubeTexture (when used as scene environment)\n\n      this._scene.traverse((c) => {\n        if (!envMap && c.material && !c.material.envMap) {\n          const properties = renderer.properties.get(c.material)\n          if ('envMap' in properties && properties.envMap instanceof Texture) envMap = properties.envMap\n        }\n      })\n\n      if (envMap) {\n        const envMapCubeUVHeight = this._scene.environment.image.height\n        setupEnvMap(reflectionsMaterial, envMap, envMapCubeUVHeight)\n      }\n    }\n\n    this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length\n    const [x, y] = this.haltonSequence[this.haltonIndex]\n    const { width, height } = this.lastSize\n    this.temporalResolvePass.velocityPass.render(renderer) // jittering the view offset each frame reduces aliasing for the reflection\n\n    if (this._camera.setViewOffset) this._camera.setViewOffset(width, height, x, y, width, height) // render reflections of current frame\n\n    this.reflectionsPass.render(renderer, inputBuffer) // compose reflection of last and current frame into one reflection\n\n    this.temporalResolvePass.render(renderer)\n\n    this._camera.clearViewOffset()\n  }\n\n  static patchDirectEnvIntensity(envMapIntensity = 0) {\n    if (envMapIntensity === 0) {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\n        'vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {',\n        'vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) { return vec3(0.0);'\n      )\n    } else {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\n        'vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );',\n        'vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness ) * ' + envMapIntensity.toFixed(5) + ';'\n      )\n    }\n  }\n}\n\nexport { SSREffect, defaultSSROptions }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}