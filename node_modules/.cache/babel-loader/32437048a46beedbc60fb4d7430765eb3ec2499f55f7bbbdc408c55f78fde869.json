{"ast":null,"code":"import { Uniform } from \"three\";\nimport { Effect, EffectAttribute, BlendFunction } from \"postprocessing\";\nimport { wrapEffect } from \"../util.js\";\nconst TiltShiftShader = {\n  fragmentShader: `\n\n    // original shader by Evan Wallace\n\n    #define MAX_ITERATIONS 100\n\n    uniform float blur;\n    uniform float taper;\n    uniform vec2 start;\n    uniform vec2 end;\n    uniform vec2 direction;\n    uniform int samples;\n\n    float random(vec3 scale, float seed) {\n        /* use the fragment position for a different seed per-pixel */\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 color = vec4(0.0);\n        float total = 0.0;\n        vec2 startPixel = vec2(start.x * resolution.x, start.y * resolution.y);\n        vec2 endPixel = vec2(end.x * resolution.x, end.y * resolution.y);\n        float f_samples = float(samples);\n        float half_samples = f_samples / 2.0;\n\n        // use screen diagonal to normalize blur radii\n        float maxScreenDistance = distance(vec2(0.0), resolution); // diagonal distance\n        float gradientRadius = taper * (maxScreenDistance);\n        float blurRadius = blur * (maxScreenDistance / 16.0);\n\n        /* randomize the lookup values to hide the fixed number of samples */\n        float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n        vec2 normal = normalize(vec2(startPixel.y - endPixel.y, endPixel.x - startPixel.x));\n        float radius = smoothstep(0.0, 1.0, abs(dot(uv * resolution - startPixel, normal)) / gradientRadius) * blurRadius;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i <= MAX_ITERATIONS; i++) {\n            if (i >= samples) { break; } // return early if over sample count\n            float f_i = float(i);\n            float s_i = -half_samples + f_i;\n            float percent = (s_i + offset - 0.5) / half_samples;\n            float weight = 1.0 - abs(percent);\n            vec4 sample_i = texture2D(inputBuffer, uv + normalize(direction) / resolution * percent * radius);\n            /* switch to pre-multiplied alpha to correctly blur transparent images */\n            sample_i.rgb *= sample_i.a;\n            color += sample_i * weight;\n            total += weight;\n        }\n        #pragma unroll_loop_end\n\n        outputColor = color / total;\n\n        /* switch back from pre-multiplied alpha */\n        outputColor.rgb /= outputColor.a + 0.00001;\n    }\n    `\n};\nclass TiltShiftEffect extends Effect {\n  constructor({\n    blendFunction = BlendFunction.NORMAL,\n    blur = 0.15,\n    // [0, 1], can go beyond 1 for extra\n    taper = 0.5,\n    // [0, 1], can go beyond 1 for extra\n    start = [0.5, 0],\n    // [0,1] percentage x,y of screenspace\n    end = [0.5, 1],\n    // [0,1] percentage x,y of screenspace\n    samples = 10,\n    // number of blur samples\n    direction = [1, 1]\n    // direction of blur\n  } = {}) {\n    super(\"TiltShiftEffect\", TiltShiftShader.fragmentShader, {\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION,\n      uniforms: /* @__PURE__ */new Map([[\"blur\", new Uniform(blur)], [\"taper\", new Uniform(taper)], [\"start\", new Uniform(start)], [\"end\", new Uniform(end)], [\"samples\", new Uniform(samples)], [\"direction\", new Uniform(direction)]])\n    });\n  }\n}\nconst TiltShift2 = wrapEffect(TiltShiftEffect, {\n  blendFunction: BlendFunction.NORMAL\n});\nexport { TiltShift2, TiltShiftEffect };","map":{"version":3,"names":["TiltShiftShader","fragmentShader","TiltShiftEffect","Effect","constructor","blendFunction","BlendFunction","NORMAL","blur","taper","start","end","samples","direction","attributes","EffectAttribute","CONVOLUTION","uniforms","Map","Uniform","TiltShift2","wrapEffect"],"sources":["/Users/kasaikazunobu/project/babel/babel-project/node_modules/@react-three/postprocessing/src/effects/TiltShift2.tsx"],"sourcesContent":["import { Uniform } from 'three'\nimport { BlendFunction, Effect, EffectAttribute } from 'postprocessing'\nimport { wrapEffect } from '../util'\n\nconst TiltShiftShader = {\n  fragmentShader: `\n\n    // original shader by Evan Wallace\n\n    #define MAX_ITERATIONS 100\n\n    uniform float blur;\n    uniform float taper;\n    uniform vec2 start;\n    uniform vec2 end;\n    uniform vec2 direction;\n    uniform int samples;\n\n    float random(vec3 scale, float seed) {\n        /* use the fragment position for a different seed per-pixel */\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 color = vec4(0.0);\n        float total = 0.0;\n        vec2 startPixel = vec2(start.x * resolution.x, start.y * resolution.y);\n        vec2 endPixel = vec2(end.x * resolution.x, end.y * resolution.y);\n        float f_samples = float(samples);\n        float half_samples = f_samples / 2.0;\n\n        // use screen diagonal to normalize blur radii\n        float maxScreenDistance = distance(vec2(0.0), resolution); // diagonal distance\n        float gradientRadius = taper * (maxScreenDistance);\n        float blurRadius = blur * (maxScreenDistance / 16.0);\n\n        /* randomize the lookup values to hide the fixed number of samples */\n        float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n        vec2 normal = normalize(vec2(startPixel.y - endPixel.y, endPixel.x - startPixel.x));\n        float radius = smoothstep(0.0, 1.0, abs(dot(uv * resolution - startPixel, normal)) / gradientRadius) * blurRadius;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i <= MAX_ITERATIONS; i++) {\n            if (i >= samples) { break; } // return early if over sample count\n            float f_i = float(i);\n            float s_i = -half_samples + f_i;\n            float percent = (s_i + offset - 0.5) / half_samples;\n            float weight = 1.0 - abs(percent);\n            vec4 sample_i = texture2D(inputBuffer, uv + normalize(direction) / resolution * percent * radius);\n            /* switch to pre-multiplied alpha to correctly blur transparent images */\n            sample_i.rgb *= sample_i.a;\n            color += sample_i * weight;\n            total += weight;\n        }\n        #pragma unroll_loop_end\n\n        outputColor = color / total;\n\n        /* switch back from pre-multiplied alpha */\n        outputColor.rgb /= outputColor.a + 0.00001;\n    }\n    `,\n}\n\nexport class TiltShiftEffect extends Effect {\n  constructor({\n    blendFunction = BlendFunction.NORMAL,\n    blur = 0.15, // [0, 1], can go beyond 1 for extra\n    taper = 0.5, // [0, 1], can go beyond 1 for extra\n    start = [0.5, 0.0], // [0,1] percentage x,y of screenspace\n    end = [0.5, 1.0], // [0,1] percentage x,y of screenspace\n    samples = 10.0, // number of blur samples\n    direction = [1, 1], // direction of blur\n  } = {}) {\n    super('TiltShiftEffect', TiltShiftShader.fragmentShader, {\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION,\n      uniforms: new Map<string, Uniform<number | number[]>>([\n        ['blur', new Uniform(blur)],\n        ['taper', new Uniform(taper)],\n        ['start', new Uniform(start)],\n        ['end', new Uniform(end)],\n        ['samples', new Uniform(samples)],\n        ['direction', new Uniform(direction)],\n      ]),\n    })\n  }\n}\n\nexport const TiltShift2 = wrapEffect(TiltShiftEffect, { blendFunction: BlendFunction.NORMAL })\n"],"mappings":";;;AAIA,MAAMA,eAAA,GAAkB;EACtBC,cAAA,EAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyDlB;AAEO,MAAMC,eAAA,SAAwBC,MAAA,CAAO;EAC1CC,YAAY;IACVC,aAAA,GAAgBC,aAAA,CAAcC,MAAA;IAC9BC,IAAA,GAAO;IAAA;IACPC,KAAA,GAAQ;IAAA;IACRC,KAAA,GAAQ,CAAC,KAAK,CAAG;IAAA;IACjBC,GAAA,GAAM,CAAC,KAAK,CAAG;IAAA;IACfC,OAAA,GAAU;IAAA;IACVC,SAAA,GAAY,CAAC,GAAG,CAAC;IAAA;EACnB,IAAI,IAAI;IACA,yBAAmBb,eAAA,CAAgBC,cAAA,EAAgB;MACvDI,aAAA;MACAS,UAAA,EAAYC,eAAA,CAAgBC,WAAA;MAC5BC,QAAA,qBAAcC,GAAA,CAAwC,CACpD,CAAC,QAAQ,IAAIC,OAAA,CAAQX,IAAI,CAAC,GAC1B,CAAC,SAAS,IAAIW,OAAA,CAAQV,KAAK,CAAC,GAC5B,CAAC,SAAS,IAAIU,OAAA,CAAQT,KAAK,CAAC,GAC5B,CAAC,OAAO,IAAIS,OAAA,CAAQR,GAAG,CAAC,GACxB,CAAC,WAAW,IAAIQ,OAAA,CAAQP,OAAO,CAAC,GAChC,CAAC,aAAa,IAAIO,OAAA,CAAQN,SAAS,CAAC,EACrC;IAAA,CACF;EACH;AACF;AAEO,MAAMO,UAAA,GAAaC,UAAA,CAAWnB,eAAA,EAAiB;EAAEG,aAAA,EAAeC,aAAA,CAAcC;AAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}