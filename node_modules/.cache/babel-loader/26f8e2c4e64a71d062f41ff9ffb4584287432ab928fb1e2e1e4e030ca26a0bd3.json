{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { SelectiveBloomEffect, BlendFunction } from \"postprocessing\";\nimport { forwardRef, useContext, useMemo, useEffect } from \"react\";\nimport { useThree } from \"@react-three/fiber\";\nimport { EffectComposerContext } from \"../EffectComposer.js\";\nimport { selectionContext } from \"../Selection.js\";\nimport { resolveRef } from \"../util.js\";\nconst addLight = (light, effect) => light.layers.enable(effect.selection.layer);\nconst removeLight = (light, effect) => light.layers.disable(effect.selection.layer);\nconst SelectiveBloom = forwardRef(function SelectiveBloom2({\n  selection = [],\n  selectionLayer = 10,\n  lights = [],\n  luminanceThreshold,\n  luminanceSmoothing,\n  intensity,\n  width,\n  height,\n  kernelSize,\n  mipmapBlur,\n  ...props\n}, forwardRef2) {\n  if (lights.length === 0) {\n    console.warn(\"SelectiveBloom requires lights to work.\");\n  }\n  const invalidate = useThree(state => state.invalidate);\n  const {\n    scene,\n    camera\n  } = useContext(EffectComposerContext);\n  const effect = useMemo(() => new SelectiveBloomEffect(scene, camera, {\n    blendFunction: BlendFunction.ADD,\n    luminanceThreshold,\n    luminanceSmoothing,\n    intensity,\n    width,\n    height,\n    kernelSize,\n    mipmapBlur,\n    ...props\n  }), [scene, camera, luminanceThreshold, luminanceSmoothing, intensity, width, height, kernelSize, mipmapBlur, props]);\n  const api = useContext(selectionContext);\n  useEffect(() => {\n    if (!api && selection) {\n      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);\n      invalidate();\n      return () => {\n        effect.selection.clear();\n        invalidate();\n      };\n    }\n  }, [effect, selection, api, invalidate]);\n  useEffect(() => {\n    effect.selection.layer = selectionLayer;\n    invalidate();\n  }, [effect, invalidate, selectionLayer]);\n  useEffect(() => {\n    if (lights && lights.length > 0) {\n      lights.forEach(light => addLight(resolveRef(light), effect));\n      invalidate();\n      return () => {\n        lights.forEach(light => removeLight(resolveRef(light), effect));\n        invalidate();\n      };\n    }\n  }, [effect, invalidate, lights, selectionLayer]);\n  useEffect(() => {\n    var _a;\n    if (api && api.enabled) {\n      if ((_a = api.selected) == null ? void 0 : _a.length) {\n        effect.selection.set(api.selected);\n        invalidate();\n        return () => {\n          effect.selection.clear();\n          invalidate();\n        };\n      }\n    }\n  }, [api, effect.selection, invalidate]);\n  return /* @__PURE__ */jsx(\"primitive\", {\n    ref: forwardRef2,\n    object: effect,\n    dispose: null\n  });\n});\nexport { SelectiveBloom };","map":{"version":3,"names":["addLight","light","effect","layers","enable","selection","layer","removeLight","disable","SelectiveBloom","forwardRef","SelectiveBloom2","selectionLayer","lights","luminanceThreshold","luminanceSmoothing","intensity","width","height","kernelSize","mipmapBlur","props","forwardRef2","length","console","warn","invalidate","useThree","state","scene","camera","useContext","EffectComposerContext","useMemo","SelectiveBloomEffect","blendFunction","BlendFunction","ADD","api","selectionContext","useEffect","set","Array","isArray","map","resolveRef","clear","forEach","enabled","_a","selected","jsx","ref","object","dispose"],"sources":["/Users/kasaikazunobu/project/babel/babel-project/node_modules/@react-three/postprocessing/src/effects/SelectiveBloom.tsx"],"sourcesContent":["import { SelectiveBloomEffect, BlendFunction } from 'postprocessing'\nimport type { BloomEffectOptions } from 'postprocessing'\nimport React, { Ref, MutableRefObject, forwardRef, useMemo, useEffect, useContext, useRef } from 'react'\nimport { Object3D } from 'three'\nimport { useThree } from '@react-three/fiber'\nimport { EffectComposerContext } from '../EffectComposer'\nimport { selectionContext } from '../Selection'\nimport { resolveRef } from '../util'\n\ntype ObjectRef = MutableRefObject<Object3D>\n\nexport type SelectiveBloomProps = BloomEffectOptions &\n  Partial<{\n    lights: Object3D[] | ObjectRef[]\n    selection: Object3D | Object3D[] | ObjectRef | ObjectRef[]\n    selectionLayer: number\n  }>\n\nconst addLight = (light: Object3D, effect: SelectiveBloomEffect) => light.layers.enable(effect.selection.layer)\nconst removeLight = (light: Object3D, effect: SelectiveBloomEffect) => light.layers.disable(effect.selection.layer)\n\nexport const SelectiveBloom = forwardRef(function SelectiveBloom(\n  {\n    selection = [],\n    selectionLayer = 10,\n    lights = [],\n    luminanceThreshold,\n    luminanceSmoothing,\n    intensity,\n    width,\n    height,\n    kernelSize,\n    mipmapBlur,\n\n    ...props\n  }: SelectiveBloomProps,\n  forwardRef: Ref<SelectiveBloomEffect>\n) {\n  if (lights.length === 0) {\n    console.warn('SelectiveBloom requires lights to work.')\n  }\n\n  const invalidate = useThree((state) => state.invalidate)\n  const { scene, camera } = useContext(EffectComposerContext)\n  const effect = useMemo(\n    () =>\n      new SelectiveBloomEffect(scene, camera, {\n        blendFunction: BlendFunction.ADD,\n        luminanceThreshold,\n        luminanceSmoothing,\n        intensity,\n        width,\n        height,\n        kernelSize,\n        mipmapBlur,\n        ...props,\n      }),\n    [scene, camera, luminanceThreshold, luminanceSmoothing, intensity, width, height, kernelSize, mipmapBlur, props]\n  )\n\n  const api = useContext(selectionContext)\n\n  useEffect(() => {\n    // Do not allow array selection if declarative selection is active\n    // TODO: array selection should probably be deprecated altogether\n    if (!api && selection) {\n      effect.selection.set(\n        Array.isArray(selection) ? (selection as Object3D[]).map(resolveRef) : [resolveRef(selection) as Object3D]\n      )\n      invalidate()\n      return () => {\n        effect.selection.clear()\n        invalidate()\n      }\n    }\n  }, [effect, selection, api, invalidate])\n\n  useEffect(() => {\n    effect.selection.layer = selectionLayer\n    invalidate()\n  }, [effect, invalidate, selectionLayer])\n\n  useEffect(() => {\n    if (lights && lights.length > 0) {\n      lights.forEach((light) => addLight(resolveRef(light), effect))\n      invalidate()\n      return () => {\n        lights.forEach((light) => removeLight(resolveRef(light), effect))\n        invalidate()\n      }\n    }\n  }, [effect, invalidate, lights, selectionLayer])\n\n  useEffect(() => {\n    if (api && api.enabled) {\n      if (api.selected?.length) {\n        effect.selection.set(api.selected)\n        invalidate()\n        return () => {\n          effect.selection.clear()\n          invalidate()\n        }\n      }\n    }\n  }, [api, effect.selection, invalidate])\n\n  return <primitive ref={forwardRef} object={effect} dispose={null} />\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}