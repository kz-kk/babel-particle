{"ast":null,"code":"import { Box2, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Matrix3, Path, Shape, ShapePath, ShapeUtils, SRGBColorSpace, Vector2, Vector3 } from 'three';\nconst COLOR_SPACE_SVG = SRGBColorSpace;\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n\n    // Default dots per inch\n    this.defaultDPI = 90;\n\n    // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n    this.defaultUnit = 'px';\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(text) {\n    const scope = this;\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      const transform = getNodeTransform(node);\n      let isDefsNode = false;\n      let path = null;\n      switch (node.nodeName) {\n        case 'svg':\n          style = parseStyle(node, style);\n          break;\n        case 'style':\n          parseCSSStylesheet(node);\n          break;\n        case 'g':\n          style = parseStyle(node, style);\n          break;\n        case 'path':\n          style = parseStyle(node, style);\n          if (node.hasAttribute('d')) path = parsePathNode(node);\n          break;\n        case 'rect':\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n        case 'polygon':\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n        case 'polyline':\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n        case 'circle':\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n        case 'ellipse':\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n        case 'line':\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n        case 'defs':\n          isDefsNode = true;\n          break;\n        case 'use':\n          style = parseStyle(node, style);\n          const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || '';\n          const usedNodeId = href.substring(1);\n          const usedNode = node.viewportElement.getElementById(usedNodeId);\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn('SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId);\n          }\n          break;\n        default:\n        // console.log( node );\n      }\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill, COLOR_SPACE_SVG);\n        }\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = {\n          node: node,\n          style: style\n        };\n      }\n      const childNodes = node.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const node = childNodes[i];\n        if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n          // Ignore everything in defs except CSS style definitions\n          // and nested defs, because it is OK by the standard to have\n          // <style/> there.\n          continue;\n        }\n        parseNode(node, style);\n      }\n      if (transform) {\n        transformStack.pop();\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n    function parsePathNode(node) {\n      const path = new ShapePath();\n      const point = new Vector2();\n      const control = new Vector2();\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute('d');\n      if (d === '' || d === 'none') return null;\n\n      // console.log( d );\n\n      const commands = d.match(/[a-df-z][^a-df-z]*/ig);\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data = command.slice(1).trim();\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n        let numbers;\n        switch (type) {\n          case 'M':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0) firstPoint.copy(point);\n            }\n            break;\n          case 'H':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'V':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'L':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'C':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'S':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'Q':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'T':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'A':\n            numbers = parseFloats(data, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'm':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0) firstPoint.copy(point);\n            }\n            break;\n          case 'h':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'v':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'l':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'c':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 's':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'q':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 't':\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'a':\n            numbers = parseFloats(data, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true;\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n            break;\n          default:\n            console.warn(command);\n        }\n\n        // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n        doSetFirstPoint = false;\n      }\n      return path;\n    }\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i => i.trim());\n        for (let j = 0; j < selectorList.length; j++) {\n          // Remove empty rules\n          const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== ''));\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n        }\n      }\n    }\n\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n      x_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n      // Ensure radii are positive\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n\n      // Compute (x1', y1')\n      const dx2 = (start.x - end.x) / 2.0;\n      const dy2 = (start.y - end.y) / 2.0;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n\n      // Compute (cx', cy')\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p;\n\n      // Ensure radii are large enough\n      const cr = x1ps / rxs + y1ps / rys;\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx;\n\n      // Step 3: Compute (cx, cy) from (cx', cy')\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n\n      // Step 4: Compute θ1 and Δθ\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n\n    /*\n    * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n    * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n    */\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('x') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('y') || 0);\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0);\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0);\n      const w = parseFloatWithUnits(node.getAttribute('width'));\n      const h = parseFloatWithUnits(node.getAttribute('height'));\n\n      // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n      // https://spencermortensen.com/articles/bezier-circle/\n      const bci = 1 - 0.551915024494;\n      const path = new ShapePath();\n\n      // top left\n      path.moveTo(x + rx, y);\n\n      // top right\n      path.lineTo(x + w - rx, y);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n      }\n\n      // bottom right\n      path.lineTo(x + w, y + h - ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n      }\n\n      // bottom left\n      path.lineTo(x + rx, y + h);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n      }\n\n      // back to top left\n      path.lineTo(x, y + ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n      }\n      return path;\n    }\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n      const r = parseFloatWithUnits(node.getAttribute('r') || 0);\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0);\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n\n    //\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      let stylesheetStyles = {};\n      if (node.hasAttribute('class')) {\n        const classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(i => i.trim());\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n        }\n      }\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n      }\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined) adjustFunction = function copy(v) {\n          if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n          return v;\n        };\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n      }\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n      addStyle('fill', 'fill');\n      addStyle('fill-opacity', 'fillOpacity', clamp);\n      addStyle('fill-rule', 'fillRule');\n      addStyle('opacity', 'opacity', clamp);\n      addStyle('stroke', 'stroke');\n      addStyle('stroke-opacity', 'strokeOpacity', clamp);\n      addStyle('stroke-width', 'strokeWidth', positive);\n      addStyle('stroke-linejoin', 'strokeLineJoin');\n      addStyle('stroke-linecap', 'strokeLineCap');\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n      addStyle('visibility', 'visibility');\n      return style;\n    }\n\n    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    }\n\n    // from https://github.com/ppvg/svg-numbers (MIT License)\n\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input);\n      }\n\n      // Character groups\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      };\n\n      // States\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = '',\n        exponent = '';\n      const result = [];\n      function throwSyntaxError(current, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n        error.partial = partial;\n        throw error;\n      }\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n        number = '';\n        exponent = '';\n      }\n      let current;\n      const length = input.length;\n      for (let i = 0; i < length; i++) {\n        current = input[i];\n\n        // check for flags\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        }\n\n        // parse until next number\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          }\n\n          // start new number\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          }\n\n          // throw on double commas (e.g. \"1, , 2\")\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n            seenComma = true;\n          }\n        }\n\n        // parse integer part\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n\n          // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        }\n\n        // parse decimal part\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n\n          // throw on double decimal points (e.g. \"1..2\")\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result);\n          }\n        }\n\n        // parse exponent part\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current;\n              continue;\n            }\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        }\n\n        // end of number\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      }\n\n      // add the last number found (if any)\n      newNumber();\n      return result;\n    }\n\n    // Units\n\n    const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px'];\n\n    // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n    const unitConversion = {\n      'mm': {\n        'mm': 1,\n        'cm': 0.1,\n        'in': 1 / 25.4,\n        'pt': 72 / 25.4,\n        'pc': 6 / 25.4,\n        'px': -1\n      },\n      'cm': {\n        'mm': 10,\n        'cm': 1,\n        'in': 1 / 2.54,\n        'pt': 72 / 2.54,\n        'pc': 6 / 2.54,\n        'px': -1\n      },\n      'in': {\n        'mm': 25.4,\n        'cm': 2.54,\n        'in': 1,\n        'pt': 72,\n        'pc': 6,\n        'px': -1\n      },\n      'pt': {\n        'mm': 25.4 / 72,\n        'cm': 2.54 / 72,\n        'in': 1 / 72,\n        'pt': 1,\n        'pc': 6 / 72,\n        'px': -1\n      },\n      'pc': {\n        'mm': 25.4 / 6,\n        'cm': 2.54 / 6,\n        'in': 1 / 6,\n        'pt': 72 / 6,\n        'pc': 1,\n        'px': -1\n      },\n      'px': {\n        'px': 1\n      }\n    };\n    function parseFloatWithUnits(string) {\n      let theUnit = 'px';\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n      let scale = undefined;\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n        if (scale < 0) {\n          // Conversion scale to pixels\n\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n        }\n      }\n      return scale * parseFloat(string);\n    }\n\n    // Transforms\n\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n        return null;\n      }\n      const transform = parseNodeTransform(node);\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform = tempTransform0;\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        const tx = parseFloatWithUnits(node.getAttribute('x'));\n        const ty = parseFloatWithUnits(node.getAttribute('y'));\n        transform.translate(tx, ty);\n      }\n      if (node.hasAttribute('transform')) {\n        const transformsTexts = node.getAttribute('transform').split(')');\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === '') continue;\n          const openParPos = transformText.indexOf('(');\n          const closeParPos = transformText.length;\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.slice(0, openParPos);\n            const array = parseFloats(transformText.slice(openParPos + 1));\n            currentTransform.identity();\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = 0;\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n                  currentTransform.translate(tx, ty);\n                }\n                break;\n              case 'rotate':\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0;\n\n                  // Angle\n                  angle = array[0] * Math.PI / 180;\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  }\n\n                  // Rotate around center (cx, cy)\n                  tempTransform1.makeTranslation(-cx, -cy);\n                  tempTransform2.makeRotation(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.makeTranslation(cx, cy);\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n                break;\n              case 'scale':\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n                  currentTransform.scale(scaleX, scaleY);\n                }\n                break;\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n                break;\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n                break;\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n                break;\n            }\n          }\n          transform.premultiply(currentTransform);\n        }\n      }\n      return transform;\n    }\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n      function transfEllipseGeneric(curve) {\n        // For math description see:\n        // https://math.stackexchange.com/questions/4544164\n\n        const a = curve.xRadius;\n        const b = curve.yRadius;\n        const cosTheta = Math.cos(curve.aRotation);\n        const sinTheta = Math.sin(curve.aRotation);\n        const v1 = new Vector3(a * cosTheta, a * sinTheta, 0);\n        const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0);\n        const f1 = v1.applyMatrix3(m);\n        const f2 = v2.applyMatrix3(m);\n        const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1);\n        const mFInv = tempTransform1.copy(mF).invert();\n        const mFInvT = tempTransform2.copy(mFInv).transpose();\n        const mQ = mFInvT.multiply(mFInv);\n        const mQe = mQ.elements;\n        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);\n        const rt1sqrt = Math.sqrt(ed.rt1);\n        const rt2sqrt = Math.sqrt(ed.rt2);\n        curve.xRadius = 1 / rt1sqrt;\n        curve.yRadius = 1 / rt2sqrt;\n        curve.aRotation = Math.atan2(ed.sn, ed.cs);\n        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;\n\n        // Do not touch angles of a full ellipse because after transformation they\n        // would converge to a sinle value effectively removing the whole curve\n\n        if (!isFullEllipse) {\n          const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1);\n          const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1);\n          const mDRF = mDsqrt.multiply(mRT).multiply(mF);\n          const transformAngle = phi => {\n            const {\n              x: cosR,\n              y: sinR\n            } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);\n            return Math.atan2(sinR, cosR);\n          };\n          curve.aStartAngle = transformAngle(curve.aStartAngle);\n          curve.aEndAngle = transformAngle(curve.aEndAngle);\n          if (isTransformFlipped(m)) {\n            curve.aClockwise = !curve.aClockwise;\n          }\n        }\n      }\n      function transfEllipseNoSkew(curve) {\n        // Faster shortcut if no skew is applied\n        // (e.g, a euclidean transform of a group containing the ellipse)\n\n        const sx = getTransformScaleX(m);\n        const sy = getTransformScaleY(m);\n        curve.xRadius *= sx;\n        curve.yRadius *= sy;\n\n        // Extract rotation angle from the matrix of form:\n        //\n        //  | cosθ sx   -sinθ sy |\n        //  | sinθ sx    cosθ sy |\n        //\n        // Remembering that tanθ = sinθ / cosθ; and that\n        // `sx`, `sy`, or both might be zero.\n        const theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);\n        curve.aRotation += theta;\n        if (isTransformFlipped(m)) {\n          curve.aStartAngle *= -1;\n          curve.aEndAngle *= -1;\n          curve.aClockwise = !curve.aClockwise;\n        }\n      }\n      const subPaths = path.subPaths;\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i];\n        const curves = subPath.curves;\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j];\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            // Transform ellipse center point\n\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n\n            // Transform ellipse shape parameters\n\n            if (isTransformSkewed(m)) {\n              transfEllipseGeneric(curve);\n            } else {\n              transfEllipseNoSkew(curve);\n            }\n          }\n        }\n      }\n    }\n    function isTransformFlipped(m) {\n      const te = m.elements;\n      return te[0] * te[4] - te[1] * te[3] < 0;\n    }\n    function isTransformSkewed(m) {\n      const te = m.elements;\n      const basisDot = te[0] * te[3] + te[1] * te[4];\n\n      // Shortcut for trivial rotations and transformations\n      if (basisDot === 0) return false;\n      const sx = getTransformScaleX(m);\n      const sy = getTransformScaleY(m);\n      return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;\n    }\n    function getTransformScaleX(m) {\n      const te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n    function getTransformScaleY(m) {\n      const te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    }\n\n    // Calculates the eigensystem of a real symmetric 2x2 matrix\n    //    [ A  B ]\n    //    [ B  C ]\n    // in the form\n    //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n    //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n    // where rt1 >= rt2.\n    //\n    // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n    // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n    function eigenDecomposition(A, B, C) {\n      let rt1, rt2, cs, sn, t;\n      const sm = A + C;\n      const df = A - C;\n      const rt = Math.sqrt(df * df + 4 * B * B);\n      if (sm > 0) {\n        rt1 = 0.5 * (sm + rt);\n        t = 1 / rt1;\n        rt2 = A * t * C - B * t * B;\n      } else if (sm < 0) {\n        rt2 = 0.5 * (sm - rt);\n      } else {\n        // This case needs to be treated separately to avoid div by 0\n\n        rt1 = 0.5 * rt;\n        rt2 = -0.5 * rt;\n      }\n\n      // Calculate eigenvectors\n\n      if (df > 0) {\n        cs = df + rt;\n      } else {\n        cs = df - rt;\n      }\n      if (Math.abs(cs) > 2 * Math.abs(B)) {\n        t = -2 * B / cs;\n        sn = 1 / Math.sqrt(1 + t * t);\n        cs = t * sn;\n      } else if (Math.abs(B) === 0) {\n        cs = 1;\n        sn = 0;\n      } else {\n        t = -0.5 * cs / B;\n        cs = 1 / Math.sqrt(1 + t * t);\n        sn = t * cs;\n      }\n      if (df > 0) {\n        t = cs;\n        cs = -sn;\n        sn = t;\n      }\n      return {\n        rt1,\n        rt2,\n        cs,\n        sn\n      };\n    }\n\n    //\n\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    const tempV2 = new Vector2();\n    const tempV3 = new Vector3();\n    const currentTransform = new Matrix3();\n    const xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4\n    });\n    const data = {\n      paths: paths,\n      xml: xml.documentElement\n    };\n\n    // console.log( paths );\n    return data;\n  }\n  static createShapes(shapePath) {\n    // Param shapePath: a shapepath as returned by the parse function of this class\n    // Returns Shape object\n\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        //1. lines are parallel or edges don't intersect\n\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        //2. lines are colinear\n\n        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          //find position of this endpoints relatively to edge1\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return {\n              x: x,\n              y: y,\n              t: classifyResult.t\n            };\n          }\n        }\n        return null;\n      } else {\n        //3. edges intersect\n\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          }\n        }\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return {\n          x: x,\n          y: y,\n          t: t1\n        };\n      }\n    }\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n      let t;\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n          if (intersection !== null && intersectionsRaw.find(i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === undefined) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n      return intersections;\n    }\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach(path => {\n        // check if the center of the bounding box is in the bounding box of the paths.\n        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach(p => {\n            allIntersections.push({\n              identifier: path.identifier,\n              isCW: path.isCW,\n              point: p\n            });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n    function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n      if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n        _fillRule = 'nonzero';\n      }\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new Vector2(scanlineMinX, centerBoundingBox.y), new Vector2(scanlineMaxX, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach(i => {\n        if (i.identifier === simplePath.identifier) {\n          baseIntersections.push(i);\n        } else {\n          otherIntersections.push(i);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x;\n\n      // build up the path hierarchy\n      const stack = [];\n      let i = 0;\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n        i++;\n      }\n      stack.push(simplePath.identifier);\n      if (_fillRule === 'evenodd') {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor\n        };\n      } else if (_fillRule === 'nonzero') {\n        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n        for (let i = 0; i < stack.length; i++) {\n          const identifier = stack[i];\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = false;\n            isHoleFor = identifier;\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = true;\n          }\n        }\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor\n        };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    }\n\n    // check for self intersecting paths\n    // TODO\n\n    // check intersecting paths\n    // TODO\n\n    // prepare paths for hole detection\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map(p => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER;\n\n      //points.forEach(p => p.y *= -1);\n\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        if (p.y > maxY) {\n          maxY = p.y;\n        }\n        if (p.y < minY) {\n          minY = p.y;\n        }\n        if (p.x > maxX) {\n          maxX = p.x;\n        }\n        if (p.x < minX) {\n          minX = p.x;\n        }\n      }\n\n      //\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n      return {\n        curves: p.curves,\n        points: points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: -1,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n      };\n    });\n    simplePaths = simplePaths.filter(sp => sp.points.length > 1);\n    for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n      simplePaths[identifier].identifier = identifier;\n    }\n\n    // check if path is solid or a hole\n    const isAHole = simplePaths.map(p => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : undefined));\n    const shapesToReturn = [];\n    simplePaths.forEach(p => {\n      const amIAHole = isAHole[p.identifier];\n      if (!amIAHole.isHole) {\n        const shape = new Shape();\n        shape.curves = p.curves;\n        const holes = isAHole.filter(h => h.isHole && h.for === p.identifier);\n        holes.forEach(h => {\n          const hole = simplePaths[h.identifier];\n          const path = new Path();\n          path.curves = hole.curves;\n          shape.holes.push(path);\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    // Param width: Stroke width\n    // Param color: As returned by THREE.Color.getStyle()\n    // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n    // Param lineCap: One of \"round\", \"square\" or \"butt\"\n    // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n    // Returns style object\n\n    width = width !== undefined ? width : 1;\n    color = color !== undefined ? color : '#000';\n    lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n    lineCap = lineCap !== undefined ? lineCap : 'butt';\n    miterLimit = miterLimit !== undefined ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    // Generates a stroke with some width around the given path.\n    // The path can be open or closed (last point equals to first point)\n    // Param points: Array of Vector2D (the path). Minimum 2 points.\n    // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n    // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n    // Param minDistance: Points closer to this distance will be merged. (Optional)\n    // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n    minDistance = minDistance !== undefined ? minDistance : 0.001;\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n    // First ensure there are no duplicated points\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2) return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0,\n      u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2;\n\n    // Get initial left and right stroke points\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint];\n\n      // Get next point\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else nextPoint = undefined;\n      } else {\n        nextPoint = points[iPoint + 1];\n      }\n\n      // Normal of previous segment in tempV2_1\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3));\n\n        // If path is straight, don't create join\n        if (dot > Number.EPSILON) {\n          // Compute inner and outer segment intersections\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext);\n          // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n\n            makeSegmentTriangles();\n          }\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n            case 'round':\n              // Segment triangles\n\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n\n              // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n              break;\n            case 'miter':\n            case 'miter-clip':\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  // Segment triangles\n\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n\n                  // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n                isMiter = true;\n              }\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n\n        makeSegmentTriangles();\n      }\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      }\n\n      // Increment loop variables\n\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n    return numVertices;\n\n    // -- End of algorithm\n\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n        currentCoordinate += 3;\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n      numVertices += 3;\n    }\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n\n          // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n\n          // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n          break;\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length;\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n          break;\n        case 'butt':\n        default:\n          // Nothing to do here\n          break;\n      }\n    }\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n\n      let dupPoints = false;\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n      if (!dupPoints) return points;\n      const newPoints = [];\n      newPoints.push(points[0]);\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i]);\n        }\n      }\n      newPoints.push(points[points.length - 1]);\n      return newPoints;\n    }\n  }\n}\nexport { SVGLoader };","map":{"version":3,"names":["Box2","BufferGeometry","FileLoader","Float32BufferAttribute","Loader","Matrix3","Path","Shape","ShapePath","ShapeUtils","SRGBColorSpace","Vector2","Vector3","COLOR_SPACE_SVG","SVGLoader","constructor","manager","defaultDPI","defaultUnit","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","isDefsNode","nodeName","parseStyle","parseCSSStylesheet","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","href","getAttributeNS","usedNodeId","substring","usedNode","viewportElement","getElementById","warn","fill","undefined","color","setStyle","transformPath","currentTransform","paths","push","userData","childNodes","i","length","transformStack","pop","copy","identity","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data","slice","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","definitions","Object","fromEntries","entries","v","stylesheets","assign","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","bci","iterator","a","b","index","regex","replace","r","subpath","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","startsWith","clamp","positive","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","SEP","INT","FLOAT","state","seenComma","number","exponent","result","throwSyntaxError","current","partial","SyntaxError","newNumber","Number","pow","Array","isArray","includes","test","units","unitConversion","string","theUnit","String","n","u","endsWith","scale","parseFloat","parseNodeTransform","premultiply","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","makeTranslation","tempTransform2","makeRotation","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","transfEllipseGeneric","curve","xRadius","yRadius","cosTheta","aRotation","sinTheta","v1","f1","f2","mF","mFInv","invert","mFInvT","transpose","mQ","multiply","mQe","elements","ed","eigenDecomposition","rt1sqrt","rt1","rt2sqrt","rt2","atan2","sn","cs","isFullEllipse","aEndAngle","aStartAngle","EPSILON","mDsqrt","mRT","mDRF","transformAngle","phi","cosR","sinR","isTransformFlipped","aClockwise","transfEllipseNoSkew","sx","getTransformScaleX","sy","getTransformScaleY","subPath","isLineCurve","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","isTransformSkewed","te","basisDot","A","B","C","t","sm","df","rt","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","createShapes","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","nom2","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","getIntersections","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","path2EdgeStart","path2EdgeEnd","intersection","find","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","points","identifier","isCW","sort","i1","i2","isHoleTo","simplePath","allPaths","scanlineMinX","scanlineMaxX","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","simplePaths","getPoints","maxY","minY","maxX","minX","isClockWise","sp","isAHole","fillRule","shapesToReturn","amIAHole","shape","holes","hole","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","u1","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl","dupPoints","distanceTo","newPoints"],"sources":["/Users/kasaikazunobu/project/ai/babel/babel-project/node_modules/three/examples/jsm/loaders/SVGLoader.js"],"sourcesContent":["import {\n\tBox2,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tMatrix3,\n\tPath,\n\tShape,\n\tShapePath,\n\tShapeUtils,\n\tSRGBColorSpace,\n\tVector2,\n\tVector3\n} from 'three';\n\nconst COLOR_SPACE_SVG = SRGBColorSpace;\n\nclass SVGLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet isDefsNode = false;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\tisDefsNode = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill, COLOR_SPACE_SVG );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tconst childNodes = node.childNodes;\n\n\t\t\tfor ( let i = 0; i < childNodes.length; i ++ ) {\n\n\t\t\t\tconst node = childNodes[ i ];\n\n\t\t\t\tif ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {\n\n\t\t\t\t\t// Ignore everything in defs except CSS style definitions\n\t\t\t\t\t// and nested defs, because it is OK by the standard to have\n\t\t\t\t\t// <style/> there.\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tparseNode( node, style );\n\n\t\t\t}\n\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tconst point = new Vector2();\n\t\t\tconst control = new Vector2();\n\n\t\t\tconst firstPoint = new Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\tif ( d === '' || d === 'none' ) return null;\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.slice( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\t// Remove empty rules\n\t\t\t\t\tconst definitions = Object.fromEntries(\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\n\t\t\t\t\t);\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tdefinitions\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\n\t\t\tconst bci = 1 - 0.551915024494;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\t// top left\n\t\t\tpath.moveTo( x + rx, y );\n\n\t\t\t// top right\n\t\t\tpath.lineTo( x + w - rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry * bci,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom right\n\t\t\tpath.lineTo( x + w, y + h - ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx + w - rx,\n\t\t\t\t\ty + h\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom left\n\t\t\tpath.lineTo( x + rx, y + h );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// back to top left\n\t\t\tpath.lineTo( x, y + ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.slice( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.slice( openParPos + 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = 0;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.makeRotation( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tfunction transfEllipseGeneric( curve ) {\n\n\t\t\t\t// For math description see:\n\t\t\t\t// https://math.stackexchange.com/questions/4544164\n\n\t\t\t\tconst a = curve.xRadius;\n\t\t\t\tconst b = curve.yRadius;\n\n\t\t\t\tconst cosTheta = Math.cos( curve.aRotation );\n\t\t\t\tconst sinTheta = Math.sin( curve.aRotation );\n\n\t\t\t\tconst v1 = new Vector3( a * cosTheta, a * sinTheta, 0 );\n\t\t\t\tconst v2 = new Vector3( - b * sinTheta, b * cosTheta, 0 );\n\n\t\t\t\tconst f1 = v1.applyMatrix3( m );\n\t\t\t\tconst f2 = v2.applyMatrix3( m );\n\n\t\t\t\tconst mF = tempTransform0.set(\n\t\t\t\t\tf1.x, f2.x, 0,\n\t\t\t\t\tf1.y, f2.y, 0,\n\t\t\t\t\t0, 0, 1,\n\t\t\t\t);\n\n\t\t\t\tconst mFInv = tempTransform1.copy( mF ).invert();\n\t\t\t\tconst mFInvT = tempTransform2.copy( mFInv ).transpose();\n\t\t\t\tconst mQ = mFInvT.multiply( mFInv );\n\t\t\t\tconst mQe = mQ.elements;\n\n\t\t\t\tconst ed = eigenDecomposition( mQe[ 0 ], mQe[ 1 ], mQe[ 4 ] );\n\t\t\t\tconst rt1sqrt = Math.sqrt( ed.rt1 );\n\t\t\t\tconst rt2sqrt = Math.sqrt( ed.rt2 );\n\n\t\t\t\tcurve.xRadius = 1 / rt1sqrt;\n\t\t\t\tcurve.yRadius = 1 / rt2sqrt;\n\t\t\t\tcurve.aRotation = Math.atan2( ed.sn, ed.cs );\n\n\t\t\t\tconst isFullEllipse =\n\t\t\t\t\t( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON;\n\n\t\t\t\t// Do not touch angles of a full ellipse because after transformation they\n\t\t\t\t// would converge to a sinle value effectively removing the whole curve\n\n\t\t\t\tif ( ! isFullEllipse ) {\n\n\t\t\t\t\tconst mDsqrt = tempTransform1.set(\n\t\t\t\t\t\trt1sqrt, 0, 0,\n\t\t\t\t\t\t0, rt2sqrt, 0,\n\t\t\t\t\t\t0, 0, 1,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst mRT = tempTransform2.set(\n\t\t\t\t\t\ted.cs, ed.sn, 0,\n\t\t\t\t\t\t- ed.sn, ed.cs, 0,\n\t\t\t\t\t\t0, 0, 1,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst mDRF = mDsqrt.multiply( mRT ).multiply( mF );\n\n\t\t\t\t\tconst transformAngle = phi => {\n\n\t\t\t\t\t\tconst { x: cosR, y: sinR } =\n\t\t\t\t\t\t\tnew Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF );\n\n\t\t\t\t\t\treturn Math.atan2( sinR, cosR );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcurve.aStartAngle = transformAngle( curve.aStartAngle );\n\t\t\t\t\tcurve.aEndAngle = transformAngle( curve.aEndAngle );\n\n\t\t\t\t\tif ( isTransformFlipped( m ) ) {\n\n\t\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction transfEllipseNoSkew( curve ) {\n\n\t\t\t\t// Faster shortcut if no skew is applied\n\t\t\t\t// (e.g, a euclidean transform of a group containing the ellipse)\n\n\t\t\t\tconst sx = getTransformScaleX( m );\n\t\t\t\tconst sy = getTransformScaleY( m );\n\n\t\t\t\tcurve.xRadius *= sx;\n\t\t\t\tcurve.yRadius *= sy;\n\n\t\t\t\t// Extract rotation angle from the matrix of form:\n\t\t\t\t//\n\t\t\t\t//  | cosθ sx   -sinθ sy |\n\t\t\t\t//  | sinθ sx    cosθ sy |\n\t\t\t\t//\n\t\t\t\t// Remembering that tanθ = sinθ / cosθ; and that\n\t\t\t\t// `sx`, `sy`, or both might be zero.\n\t\t\t\tconst theta =\n\t\t\t\t\tsx > Number.EPSILON\n\t\t\t\t\t\t? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] )\n\t\t\t\t\t\t: Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] );\n\n\t\t\t\tcurve.aRotation += theta;\n\n\t\t\t\tif ( isTransformFlipped( m ) ) {\n\n\t\t\t\t\tcurve.aStartAngle *= - 1;\n\t\t\t\t\tcurve.aEndAngle *= - 1;\n\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\t// Transform ellipse center point\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\t// Transform ellipse shape parameters\n\n\t\t\t\t\t\tif ( isTransformSkewed( m ) ) {\n\n\t\t\t\t\t\t\ttransfEllipseGeneric( curve );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttransfEllipseNoSkew( curve );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformFlipped( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0;\n\n\t\t}\n\n\t\tfunction isTransformSkewed( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\tconst basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ];\n\n\t\t\t// Shortcut for trivial rotations and transformations\n\t\t\tif ( basisDot === 0 ) return false;\n\n\t\t\tconst sx = getTransformScaleX( m );\n\t\t\tconst sy = getTransformScaleY( m );\n\n\t\t\treturn Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t// Calculates the eigensystem of a real symmetric 2x2 matrix\n\t\t//    [ A  B ]\n\t\t//    [ B  C ]\n\t\t// in the form\n\t\t//    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n\t\t//    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n\t\t// where rt1 >= rt2.\n\t\t//\n\t\t// Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n\t\t// -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n\t\tfunction eigenDecomposition( A, B, C ) {\n\n\t\t\tlet rt1, rt2, cs, sn, t;\n\t\t\tconst sm = A + C;\n\t\t\tconst df = A - C;\n\t\t\tconst rt = Math.sqrt( df * df + 4 * B * B );\n\n\t\t\tif ( sm > 0 ) {\n\n\t\t\t\trt1 = 0.5 * ( sm + rt );\n\t\t\t\tt = 1 / rt1;\n\t\t\t\trt2 = A * t * C - B * t * B;\n\n\t\t\t} else if ( sm < 0 ) {\n\n\t\t\t\trt2 = 0.5 * ( sm - rt );\n\n\t\t\t} else {\n\n\t\t\t\t// This case needs to be treated separately to avoid div by 0\n\n\t\t\t\trt1 = 0.5 * rt;\n\t\t\t\trt2 = - 0.5 * rt;\n\n\t\t\t}\n\n\t\t\t// Calculate eigenvectors\n\n\t\t\tif ( df > 0 ) {\n\n\t\t\t\tcs = df + rt;\n\n\t\t\t} else {\n\n\t\t\t\tcs = df - rt;\n\n\t\t\t}\n\n\t\t\tif ( Math.abs( cs ) > 2 * Math.abs( B ) ) {\n\n\t\t\t\tt = - 2 * B / cs;\n\t\t\t\tsn = 1 / Math.sqrt( 1 + t * t );\n\t\t\t\tcs = t * sn;\n\n\t\t\t} else if ( Math.abs( B ) === 0 ) {\n\n\t\t\t\tcs = 1;\n\t\t\t\tsn = 0;\n\n\t\t\t} else {\n\n\t\t\t\tt = - 0.5 * cs / B;\n\t\t\t\tcs = 1 / Math.sqrt( 1 + t * t );\n\t\t\t\tsn = t * cs;\n\n\t\t\t}\n\n\t\t\tif ( df > 0 ) {\n\n\t\t\t\tt = cs;\n\t\t\t\tcs = - sn;\n\t\t\t\tsn = t;\n\n\t\t\t}\n\n\t\t\treturn { rt1, rt2, cs, sn };\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new Matrix3();\n\t\tconst tempTransform1 = new Matrix3();\n\t\tconst tempTransform2 = new Matrix3();\n\t\tconst tempTransform3 = new Matrix3();\n\t\tconst tempV2 = new Vector2();\n\t\tconst tempV3 = new Vector3();\n\n\t\tconst currentTransform = new Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\tstatic createShapes( shapePath ) {\n\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\n\t\t// Returns Shape object\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: - 1, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\n\n\t\tfor ( let identifier = 0; identifier < simplePaths.length; identifier ++ ) {\n\n\t\t\tsimplePaths[ identifier ].identifier = identifier;\n\n\t\t}\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, ( shapePath.userData ? shapePath.userData.style.fillRule : undefined ) ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new Shape();\n\t\t\t\tshape.curves = p.curves;\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\n\t\t\t\t\tconst path = new Path();\n\t\t\t\t\tpath.curves = hole.curves;\n\t\t\t\t\tshape.holes.push( path );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some width around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new Vector2();\n\t\tconst tempV2_2 = new Vector2();\n\t\tconst tempV2_3 = new Vector2();\n\t\tconst tempV2_4 = new Vector2();\n\t\tconst tempV2_5 = new Vector2();\n\t\tconst tempV2_6 = new Vector2();\n\t\tconst tempV2_7 = new Vector2();\n\t\tconst lastPointL = new Vector2();\n\t\tconst lastPointR = new Vector2();\n\t\tconst point0L = new Vector2();\n\t\tconst point0R = new Vector2();\n\t\tconst currentPointL = new Vector2();\n\t\tconst currentPointR = new Vector2();\n\t\tconst nextPointL = new Vector2();\n\t\tconst nextPointR = new Vector2();\n\t\tconst innerPoint = new Vector2();\n\t\tconst outerPoint = new Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot > Number.EPSILON ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\nexport { SVGLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}